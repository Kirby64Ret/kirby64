#include <ultra64.h>
#include <macros.h>

#ifdef MIPS_TO_C
// generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80020F40(s32 arg0, s32 arg1, s32 arg2, ? arg3) {
    s32 temp_a2;
    void *temp_a1;
    void *temp_a3;
    void *temp_a3_2;
    void *temp_a3_3;
    void *temp_v0;
    void *temp_v1;
    void *phi_a0;
    void *phi_v1;
    void *phi_v0;
    void *phi_v0_2;
    s32 phi_a2;
    void *phi_v0_3;

    if (arg2 >= 0) {
        if (arg2 < 0x11) {
            temp_a1 = (arg2 << 5) + &D_8003F440;
            temp_v0 = gDisplayListHeads;
            if (*temp_a1 == 0) {
                phi_v0 = temp_v0;
            } else {
                temp_a3 = temp_v0;
                temp_a3->unk0 = ((((((D_8003F3C8 + arg0) * gCurrScreenWidth) / 0x140) & 0x3FF) << 0xE) | 0xF6000000) | (((((arg1 + D_8003F3CC) * gCurrScreenHeight) / 0xF0) & 0x3FF) * 4);
                temp_a3->unk4 = (((((D_8003F3C0 + arg0) * gCurrScreenWidth) / 0x140) & 0x3FF) << 0xE) | (((((arg1 + D_8003F3C4) * gCurrScreenHeight) / 0xF0) & 0x3FF) * 4);
                phi_v0 = temp_v0 + 8;
            }
            phi_a0 = temp_a1 + 4;
            phi_v1 = &D_8003F3D0;
            phi_a2 = 1;
loop_6:
            temp_a2 = phi_a2 + 2;
            phi_v0_2 = phi_v0;
            if (phi_a0->unk0 != 0) {
                temp_a3_2 = phi_v0;
                temp_a3_2->unk0 = ((((((phi_v1->unk8 + arg0) * gCurrScreenWidth) / 0x140) & 0x3FF) << 0xE) | 0xF6000000) | (((((arg1 + phi_v1->unkC) * gCurrScreenHeight) / 0xF0) & 0x3FF) * 4);
                temp_a3_2->unk4 = (((((phi_v1->unk0 + arg0) * gCurrScreenWidth) / 0x140) & 0x3FF) << 0xE) | (((((arg1 + phi_v1->unk4) * gCurrScreenHeight) / 0xF0) & 0x3FF) * 4);
                phi_v0_2 = phi_v0 + 8;
            }
            temp_v1 = phi_v1 + 0x10;
            phi_v0_3 = phi_v0_2;
            if (phi_a0->unk4 != 0) {
                temp_a3_3 = phi_v0_2;
                temp_a3_3->unk0 = ((((((temp_v1->unk8 + arg0) * gCurrScreenWidth) / 0x140) & 0x3FF) << 0xE) | 0xF6000000) | (((((arg1 + temp_v1->unkC) * gCurrScreenHeight) / 0xF0) & 0x3FF) * 4);
                temp_a3_3->unk4 = (((((temp_v1->unk0 + arg0) * gCurrScreenWidth) / 0x140) & 0x3FF) << 0xE) | (((((arg1 + temp_v1->unk4) * gCurrScreenHeight) / 0xF0) & 0x3FF) * 4);
                phi_v0_3 = phi_v0_2 + 8;
            }
            temp_v1 = temp_v1 + 0x10;
            phi_a0 = (phi_a0 + 4) + 4;
            phi_v1 = temp_v1;
            phi_v0 = phi_v0_3;
            phi_a2 = temp_a2;
            if (temp_a2 != 7) {
                goto loop_6;
            }
            D_80096520 = temp_v1;
            gDisplayListHeads = phi_v0_3;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80020F40.s")
#endif

#ifdef MIPS_TO_C
// generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
Failed to decompile function func_80021444:

Label L800215AC_ovl0_before refers to a delay slot; this is currently not supported.
Please modify the assembly to work around it (e.g. copy the instruction
to all jump sources and move the label, or add a nop to the delay slot).

This label was auto-generated as the target for a branch-likely
instruction (e.g. beql); you can also try to turn that into a non-likely
branch if that's equivalent in this context, i.e., if it's okay to
execute its delay slot unconditionally.
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021444.s")
#endif

#ifdef MIPS_TO_C
// generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800215F0(s32 arg4) {
    func_80021444(0, arg4);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_800215F0.s")
#endif

#ifdef MIPS_TO_C
// generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80021618(f32 arg2, s32 arg4, s32 arg5) {
    func_80021444(arg2, ((arg4 * 4) + 0x80040000)->unk-9A0 * arg2, arg4, arg5);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021618.s")
#endif

#ifdef MIPS_TO_C
// generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_80021668(void *arg0, s32 arg1, s32 arg2, s32 arg3, s32 arg4) {
    arg0->unk0 = (((((gCurrScreenWidth * arg3) / 0x140) & 0x3FF) << 0xE) | 0xF6000000) | ((((arg4 * gCurrScreenHeight) / 0xF0) & 0x3FF) * 4);
    arg0->unk4 = ((((gCurrScreenWidth * arg1) / 0x140) & 0x3FF) << 0xE) | ((((arg2 * gCurrScreenHeight) / 0xF0) & 0x3FF) * 4);
    return &gCurrScreenWidth;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021668.s")
#endif

#ifdef MIPS_TO_C
// generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80021764(void *arg0) {
    s32 temp_s0_2;
    u32 temp_v1;
    u32 temp_v1_2;
    u32 temp_v1_3;
    void *temp_s0;
    void *temp_s1;
    void *temp_s1_10;
    void *temp_s1_11;
    void *temp_s1_12;
    void *temp_s1_13;
    void *temp_s1_14;
    void *temp_s1_2;
    void *temp_s1_3;
    void *temp_s1_4;
    void *temp_s1_5;
    void *temp_s1_6;
    void *temp_s1_7;
    void *temp_s1_8;
    void *temp_s1_9;
    void *temp_s3;
    void *temp_s3_2;
    void *temp_s3_3;
    u32 phi_v0;
    u32 phi_v0_2;
    u32 phi_v0_3;
    s32 phi_s0;

    func_8001663C(&gDisplayListHeads, arg0->unk3C, 0, arg0);
    gDPPipeSync(gDisplayListHeads[0]++);
    temp_s1_2 = gDisplayListHeads;
    gDisplayListHeads = temp_s1_2 + 8;
    temp_s1_2->unk4 = 0x300000;
    temp_s1_2->unk0 = 0xE3000A01;
    temp_s1_3 = gDisplayListHeads;
    gDisplayListHeads = temp_s1_3 + 8;
    temp_s1_3->unk4 = 0;
    temp_s1_3->unk0 = 0xE200001C;
    temp_s0 = gDisplayListHeads;
    gDisplayListHeads = temp_s0 + 8;
    temp_s0->unk0 = 0xF7000000;
    temp_s0->unk4 = func_800078F0(0xFF0000FF);
    func_80021618(0x28, 0x15, D_8004A430 * 0.00390625f, 3, 2, 1);
    func_80021618(0x4B, 0x15, D_8004A434 * 0.00390625f, 3, 2, 1);
    func_80021618(0x6E, 0x15, D_80048C74 * 0.00390625f, 3, 2, 1);
    func_80021618(0x9B, 0x15, (D_8004A430 * 0.00390625f) + (D_8004A434 * 0.00390625f), 3, 2, 1);
    func_80021618(0xD7, 0x15, D_80095DC0 * 0.00390625f, 3, 2, 1);
    func_80021618(0xFA, 0x15, D_80048C78 * 0.00390625f, 3, 2, 1);
    temp_s1_4 = gDisplayListHeads;
    gDisplayListHeads = temp_s1_4 + 8;
    temp_s1_4->unk4 = 0;
    temp_s1_4->unk0 = 0xE7000000;
    temp_v1 = D_8004A430 >> 2;
    phi_v0 = temp_v1;
    if (temp_v1 >= 0x101) {
        phi_v0 = 0x100;
    }
    temp_s1_5 = gDisplayListHeads;
    gDisplayListHeads = temp_s1_5 + 8;
    func_80021668(temp_s1_5, 0x3E, 0x1F, phi_v0 + 0x3E, 0x20);
    temp_s1_6 = gDisplayListHeads;
    gDisplayListHeads = temp_s1_6 + 8;
    temp_s1_6->unk4 = 0;
    temp_s1_6->unk0 = 0xE7000000;
    temp_s3 = gDisplayListHeads;
    gDisplayListHeads = temp_s3 + 8;
    temp_s3->unk0 = 0xF7000000;
    temp_s3->unk4 = func_800078F0(0xFF00FFFF);
    temp_v1_2 = D_8004A434 >> 2;
    if (temp_v1_2 >= 0x101) {
        phi_v0_2 = 0x100;
    } else {
        phi_v0_2 = temp_v1_2;
    }
    temp_s1_7 = gDisplayListHeads;
    gDisplayListHeads = temp_s1_7 + 8;
    func_80021668(temp_s1_7, 0x3E, 0x21, phi_v0_2 + 0x3E, 0x22);
    temp_s1_8 = gDisplayListHeads;
    gDisplayListHeads = temp_s1_8 + 8;
    temp_s1_8->unk4 = 0;
    temp_s1_8->unk0 = 0xE7000000;
    temp_s3_2 = gDisplayListHeads;
    gDisplayListHeads = temp_s3_2 + 8;
    temp_s3_2->unk0 = 0xF7000000;
    temp_s3_2->unk4 = func_800078F0(0xFF00FF);
    temp_v1_3 = D_80048C74 >> 2;
    if (temp_v1_3 >= 0x101) {
        phi_v0_3 = 0x100;
    } else {
        phi_v0_3 = temp_v1_3;
    }
    temp_s1_9 = gDisplayListHeads;
    gDisplayListHeads = temp_s1_9 + 8;
    func_80021668(temp_s1_9, 0x3E, 0x23, phi_v0_3 + 0x3E, 0x24);
    temp_s1_10 = gDisplayListHeads;
    gDisplayListHeads = temp_s1_10 + 8;
    temp_s1_10->unk4 = 0;
    temp_s1_10->unk0 = 0xE7000000;
    temp_s3_3 = gDisplayListHeads;
    gDisplayListHeads = temp_s3_3 + 8;
    temp_s3_3->unk0 = 0xF7000000;
    temp_s3_3->unk4 = func_800078F0(0x101010FF);
    phi_s0 = 0x3E;
loop_9:
    temp_s1_11 = gDisplayListHeads;
    gDisplayListHeads = temp_s1_11 + 8;
    func_80021668(temp_s1_11, phi_s0, 0x1F, phi_s0, 0x24);
    temp_s0_2 = phi_s0 + 0x40;
    phi_s0 = temp_s0_2;
    if (temp_s0_2 != 0x13E) {
        goto loop_9;
    }
    gDPPipeSync(gDisplayListHeads[0]++);
    temp_s1_13 = gDisplayListHeads;
    gDisplayListHeads = temp_s1_13 + 8;
    temp_s1_13->unk4 = 0;
    temp_s1_13->unk0 = 0xE3000A01;
    temp_s1_14 = gDisplayListHeads;
    gDisplayListHeads = temp_s1_14 + 8;
    temp_s1_14->unk0 = 0xE200001C;
    temp_s1_14->unk4 = 0x552078;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021764.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c
? func_80021CB4(s32 arg0, s32 arg1, s32 arg2) {
    if (func_8000B688(-2) != 0) {
        return 0;
    }
    return func_8000BD3C(-2, &D_8000B6B4, arg0, arg1, &D_80021764, arg2, 0, 0, 0, 0, 0, 0, 0);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021CB4.s")
#endif

// hidden file boundary?

extern struct {
    OSThread thread;
    u64 stack[0x800 / sizeof(u64)];
    OSMesgQueue mesgQueue; // D_80096ED8
    OSMesg mesg;
    u16 *framebuffer;
    u16 width; // gCurrScreenWidth
    u16 height;
} gCrashScreen;


#ifdef MIPS_TO_C
void crash_screen_draw_rect(s32 x, s32 y, s32 w, s32 h) {
    u16 *ptr;
    s32 i, j;

    ptr = gCrashScreen.framebuffer + gCrashScreen.width * y + x;
    for (i = 0; i < h; i++) {
        for (j = 0; j < w; j++) {
            // 0xe738 = 0b1110011100111000
            *ptr = ((*ptr & 0xe738) >> 2) | 1;
            ptr+=4;
        }
        ptr += gCrashScreen.width - w;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021D34.s")
#endif

extern u16 *osViGetCurrentFramebuffer(void);

extern u32 D_8003F70C[];
extern u32 gCurrScreenWidth;
#ifdef MIPS_TO_C
void crash_screen_draw_glyph(s32 x, s32 y, s32 glyph) {
    const u32 *data;
    u16 *ptr;
    u32 bit;
    u32 rowMask;
    s32 i, j;

    // TODO: output u32 for these textures and remove this ugly cast
    data = D_8003F70C[glyph / 5 * 7];
    // ptr = (osViGetCurrentFramebuffer() + ((gCurrScreenWidth * y) * 2)) + (x * 2);
    ptr = (osViGetCurrentFramebuffer())[gCurrScreenWidth * y + x];
    // ptr = osViGetCurrentFramebuffer() + gCrashScreen.width * (y) + (x);

    for (i = 0; i < 7; i++) {
        bit = (0x80000000U) >> ((glyph % 5) * 6) / 2;
        rowMask = *data++;

        for (j = 0; j < 6; j++) {
            *ptr++ = (bit & rowMask) ? 0xffff : 1;
            bit >>= 1;
        }
        // ptr += gCrashScreen.width - 6;
        ptr += gCurrScreenWidth - 6;
        
    }
}
// generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
u32 crash_screen_draw_glyph(s32 arg0, s32 arg1, s32 arg2) {
    void *sp1C;
    s32 temp_a0;
    s32 temp_t0;
    u32 temp_t1;
    u32 temp_t2;
    u32 temp_v0;
    void *temp_a3;
    void *temp_v1;
    void *phi_a3;
    void *phi_v1;
    s32 phi_t0;

    temp_a3 = ((arg2 / 5) * 0x1C) + &D_8003F70C;
    sp1C = temp_a3;
    temp_t1 = 0x80000000 >> ((arg2 % 5) * 6);
    temp_t2 = temp_t1 >> 1;
    phi_a3 = temp_a3;
    phi_v1 = (osViGetCurrentFramebuffer(temp_a3) + ((gCurrScreenWidth * arg1) * 2)) + (arg0 * 2);
    phi_t0 = 0;
loop_1:
    temp_a0 = *phi_a3;
    if ((temp_t1 & temp_a0) != 0) {
        *phi_v1 = 0xFFFF;
    } else {
        *phi_v1 = 1;
    }
    temp_v1 = phi_v1 + 2;
    if ((temp_t2 & temp_a0) != 0) {
        *temp_v1 = 0xFFFF;
    } else {
        *temp_v1 = 1;
    }
    temp_v0 = temp_t2 >> 1;
    temp_v1 = temp_v1 + 2;
    if ((temp_v0 & temp_a0) != 0) {
        *temp_v1 = 0xFFFF;
    } else {
        *temp_v1 = 1;
    }
    temp_v0 = temp_v0 >> 1;
    temp_v1 = temp_v1 + 2;
    if ((temp_v0 & temp_a0) != 0) {
        *temp_v1 = 0xFFFF;
    } else {
        *temp_v1 = 1;
    }
    temp_v0 = temp_v0 >> 1;
    temp_v1 = temp_v1 + 2;
    if ((temp_v0 & temp_a0) != 0) {
        *temp_v1 = 0xFFFF;
    } else {
        *temp_v1 = 1;
    }
    temp_v0 = temp_v0 >> 1;
    temp_v1 = temp_v1 + 2;
    if ((temp_v0 & temp_a0) != 0) {
        *temp_v1 = 0xFFFF;
    } else {
        *temp_v1 = 1;
    }
    temp_t0 = phi_t0 + 1;
    phi_a3 = phi_a3 + 4;
    phi_v1 = ((temp_v1 + 2) + (gCurrScreenWidth * 2)) - 0xC;
    phi_t0 = temp_t0;
    if (temp_t0 != 7) {
        goto loop_1;
    }
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021E00.s")
#endif

char *write_to_buf(char *buffer, const char *data, size_t size) {
    return (char *) memcpy(buffer, data, size) + size;
}
#include "libc/stdarg.h"
extern u8 D_8003F68C[128];
// something's screwy with this func
#ifdef MIPS_TO_C
void crash_screen_print(s32 x, s32 y, const char *fmt, ...) {
    char *ptr;
    u32 glyph;
    s32 size;
    char buf[0x100];

    va_list args;
    va_start(args, fmt);

    size = _Printf(write_to_buf, buf, fmt, args);

    if (size > 0) {
        ptr = buf;

        while (size > 0) {

            glyph = D_8003F68C[*ptr & 0x7f];

            if (glyph != 0xff) {
                crash_screen_draw_glyph(x, y, glyph);
            }

            size--;

            ptr++;
            x += 6;
        }
    }

    va_end(args);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021FA4.s")
#endif


void crash_screen_sleep(s32 ms) {
    u64 cycles = ms * 1000LL * 3000LL / 64ULL;
    osSetTime(0);
    while (osGetTime() < cycles) {
    }
}

extern const char *D_80040F14, *D_80040F20;
void crash_screen_print_float_reg(s32 x, s32 y, s32 regNum, void *addr) {
    u32 bits;
    s32 exponent;

    bits = *(u32 *) addr;
    exponent = ((bits & 0x7f800000U) >> 0x17) - 0x7f;
    if ((exponent >= -0x7e && exponent <= 0x7f) || bits == 0) {
        crash_screen_print(x, y, &D_80040F14, regNum, *(f32 *) addr);
    } else {
        crash_screen_print(x, y, &D_80040F20, regNum, bits);
    }
}

extern const char *D_80040F38;
extern const char *D_80040F2C;
extern char *D_8003F854[];
void crash_screen_print_fpcsr(u32 fpcsr) {
    s32 i;
    u32 bit;

    bit = 1 << 17;
    crash_screen_print(30, 155, &D_80040F2C, fpcsr);
    for (i = 0; i < 6; i++) {
        if (fpcsr & bit) {
            crash_screen_print(132, 155, &D_80040F38, D_8003F854[i]);
            return;
        }
        bit >>= 1;
    }
}

extern u16 D_80048F20;
#ifdef MIPS_TO_C
u8 func_80022248(s32 arg0, s32 arg1) {
    while (arg0 != D_80048F20) {
        crash_screen_sleep(0x10);
        func_8000464C();
        if (arg1 != 0 && osViGetCurrentFramebuffer() != arg1) {
            return 1;
        }
    }
    return 0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022248.s")
#endif

#ifdef MIPS_TO_C
// generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800222C4(OSThread *thread, s32 arg1) {
    __OSThreadContext *temp_s1;
    __OSThreadContext *temp_s1_2;
    s32 temp_s2;
    s32 temp_s2_2;
    s32 temp_v1;
    s32 temp_v1_2;
    u32 temp_v0;
    u32 temp_v0_2;
    void *temp_a3;
    void *temp_s0;
    void *temp_s0_2;
    s32 phi_s2;
    s32 phi_s2_2;
    void *phi_s0;
    s32 phi_s1;
    s32 phi_s2_3;

    temp_s2 = (((thread->context.cause >> 2) & 0x1F) << 0x10) >> 0x10;
    phi_s2 = temp_s2;
    if (temp_s2 == 0x17) {
        phi_s2 = 0x10;
    }
    phi_s2_2 = phi_s2;
    if (phi_s2 == 0x1F) {
        phi_s2_2 = 0x11;
    }
    osWritebackDCacheAll();
    if (arg1 != 0) {
        crash_screen_draw_rect(0x19, 0x14, 0x10E, 0x19);
        if (arg1 != 2) {
            crash_screen_print(0x1E, 0x19, &D_80040F40, thread->id, ((phi_s2_2 * 4) + 0x80040000)->unk-7F4);
        } else {
            crash_screen_print(0x1E, 0x19, &D_80040F50, thread->id, &D_80040F60);
        }
        if (phi_s2_2 == 0) {
            crash_screen_print(0xA0, 0x19, &D_80040F6C, (thread->context.cause >> 8) & 0xFF);
            crash_screen_print(0xD2, 0x19, &D_80040F78, 0xA4300008);
        }
        temp_s1 = &thread->context;
        crash_screen_print(0x1E, 0x23, &D_80040F84, temp_s1->pc, temp_s1->sr, temp_s1->badvaddr);
        osWritebackDCacheAll();
        func_80022248(0, 0);
        func_80022248(0x2030, 0);
    }
    temp_s1_2 = &thread->context;
    crash_screen_draw_rect(0x19, 0x14, 0x10E, 0xD2);
    if (arg1 != 2) {
        crash_screen_print(0x1E, 0x19, &D_80040FA4, thread->id, ((phi_s2_2 * 4) + 0x80040000)->unk-7F4);
    } else {
        crash_screen_print(0x1E, 0x19, &D_80040FB4, thread->id, &D_80040FC4);
    }
    crash_screen_print(0x1E, 0x23, &D_80040FD0, temp_s1_2->pc, temp_s1_2->sr, temp_s1_2->badvaddr);
    if (phi_s2_2 == 0) {
        crash_screen_print(0xA0, 0x19, &D_80040FF0, (temp_s1_2->cause >> 8) & 0xFF);
        crash_screen_print(0xD2, 0x19, &D_80040FFC, 0xA4300008);
    }
    crash_screen_print(0x1E, 0x32, &D_80041008, temp_s1_2->unk4, temp_s1_2->unkC, temp_s1_2->unk14);
    crash_screen_print(0x1E, 0x3C, &D_80041028, temp_s1_2->unk1C, temp_s1_2->unk24, temp_s1_2->unk2C);
    crash_screen_print(0x1E, 0x46, &D_80041048, temp_s1_2->unk34, temp_s1_2->unk3C, temp_s1_2->unk44);
    crash_screen_print(0x1E, 0x50, &D_80041068, temp_s1_2->unk4C, temp_s1_2->unk54, temp_s1_2->unk5C);
    crash_screen_print(0x1E, 0x5A, &D_80041088, temp_s1_2->unk64, temp_s1_2->unk6C, temp_s1_2->unk74);
    crash_screen_print(0x1E, 0x64, &D_800410A8, temp_s1_2->unk7C, temp_s1_2->unk84, temp_s1_2->unk8C);
    crash_screen_print(0x1E, 0x6E, &D_800410C8, temp_s1_2->unk94, temp_s1_2->unk9C, temp_s1_2->unkA4);
    crash_screen_print(0x1E, 0x78, &D_800410E8, temp_s1_2->unkAC, temp_s1_2->unkB4, temp_s1_2->unkBC);
    crash_screen_print(0x1E, 0x82, &D_80041108, temp_s1_2->unkC4, temp_s1_2->unkCC, temp_s1_2->unkD4);
    crash_screen_print(0x1E, 0x8C, &D_80041128, temp_s1_2->unkDC, temp_s1_2->unkE4);
    crash_screen_print_fpcsr(temp_s1_2->fpcsr);
    crash_screen_print_float_reg(0x1E, 0xAA, 0, &temp_s1_2->fp0.f.f_even);
    crash_screen_print_float_reg(0x78, 0xAA, 2, &temp_s1_2->fp2.f.f_even);
    crash_screen_print_float_reg(0xD2, 0xAA, 4, &temp_s1_2->fp4.f.f_even);
    crash_screen_print_float_reg(0x1E, 0xB4, 6, &temp_s1_2->fp6.f.f_even);
    crash_screen_print_float_reg(0x78, 0xB4, 8, &temp_s1_2->fp8.f.f_even);
    crash_screen_print_float_reg(0xD2, 0xB4, 0xA, &temp_s1_2->fp10.f.f_even);
    crash_screen_print_float_reg(0x1E, 0xBE, 0xC, &temp_s1_2->fp12.f.f_even);
    crash_screen_print_float_reg(0x78, 0xBE, 0xE, &temp_s1_2->fp14.f.f_even);
    crash_screen_print_float_reg(0xD2, 0xBE, 0x10, &temp_s1_2->fp16.f.f_even);
    crash_screen_print_float_reg(0x1E, 0xC8, 0x12, &temp_s1_2->fp18.f.f_even);
    crash_screen_print_float_reg(0x78, 0xC8, 0x14, &temp_s1_2->fp20.f.f_even);
    crash_screen_print_float_reg(0xD2, 0xC8, 0x16, &temp_s1_2->fp22.f.f_even);
    crash_screen_print_float_reg(0x1E, 0xD2, 0x18, &temp_s1_2->fp24.f.f_even);
    crash_screen_print_float_reg(0x78, 0xD2, 0x1A, &temp_s1_2->fp26.f.f_even);
    crash_screen_print_float_reg(0xD2, 0xD2, 0x1C, &temp_s1_2->fp28.f.f_even);
    crash_screen_print_float_reg(0x1E, 0xDC, 0x1E, &temp_s1_2->fp30.f.f_even);
    osWritebackDCacheAll();
    func_80022248(0, 0);
    func_80022248(0x2030, 0);
    crash_screen_draw_rect(0x19, 0x14, 0x10E, 0xD2);
    temp_a3 = temp_s1_2->unkD4;
    temp_s0 = temp_a3;
    crash_screen_print(0x1A, 0x14, &D_8004113C, temp_a3);
    phi_s0 = temp_s0;
    phi_s1 = 0x1E;
    phi_s2_3 = 0;
loop_17:
    temp_v1 = phi_s0->unk0;
    temp_v0 = ((temp_v1 & 0x7F800000) >> 0x17) - 0x7F;
    if ((temp_v0 < -0x7E) || (temp_v0 >= 0x80)) {
        if (temp_v1 == 0) {
block_20:
            crash_screen_print(0x1A, phi_s1, &D_8004114C, phi_s2_3, phi_s0->unk0, phi_s0->unk1, phi_s0->unk2, phi_s0->unk3, (bitwise f32) phi_s0->unk0);
        } else {
            crash_screen_print(0x1A, phi_s1, &D_80041168, phi_s2_3, phi_s0->unk0, phi_s0->unk1, phi_s0->unk2, phi_s0->unk3, temp_v1);
        }
    } else {
        goto block_20;
    }
    temp_v1_2 = phi_s0->unk4;
    temp_s0_2 = phi_s0 + 4;
    temp_v0_2 = ((temp_v1_2 & 0x7F800000) >> 0x17) - 0x7F;
    if ((temp_v0_2 < -0x7E) || (temp_v0_2 >= 0x80)) {
        if (temp_v1_2 == 0) {
block_25:
            crash_screen_print(0xAC, phi_s1, &D_80041184, temp_s0_2->unk0, temp_s0_2->unk1, temp_s0_2->unk2, temp_s0_2->unk3, (bitwise f32) temp_s0_2->unk0);
        } else {
            crash_screen_print(0xAC, phi_s1, &D_8004119C, temp_s0_2->unk0, temp_s0_2->unk1, temp_s0_2->unk2, temp_s0_2->unk3, temp_v1_2);
        }
    } else {
        goto block_25;
    }
    temp_s2_2 = phi_s2_3 + 8;
    phi_s0 = temp_s0_2 + 4;
    phi_s1 = phi_s1 + 0xA;
    phi_s2_3 = temp_s2_2;
    if (temp_s2_2 != 0x98) {
        goto loop_17;
    }
    osWritebackDCacheAll();
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_800222C4.s")
#endif

OSThread *get_crashed_thread(void) {
    OSThread *thread;

    thread = __osGetActiveQueue();
    while (thread->priority != -1) {
        if (thread->priority > OS_PRIORITY_IDLE && thread->priority < OS_PRIORITY_MAX
            && (thread->flags & 3) != 0) {
            return thread;
        }
        thread = thread->tlnext;
    }
    return NULL;
}

#ifdef MIPS_TO_C
// generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80022A38(s32 arg0) {
    D_80096EF8 = arg0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022A38.s")
#endif

#ifdef MIPS_TO_C
// generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80022A44(s32 arg0, ?32 arg1) {
    D_8003F86C = arg0;
    D_8003F870 = arg1;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022A44.s")
#endif


// another crash_screen_print type func?
#ifdef MIPS_TO_C
// generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80022A58(s32 arg0, ? arg1) {
    ? sp48;
    s32 temp_s3;
    s32 temp_t0;
    s32 temp_v0;
    u8 temp_a2;
    u8 temp_v0_2;
    ? *phi_s4;
    s32 phi_s3;

    temp_v0 = _Printf(&D_80021F80, &sp48, arg0, arg1);
    if (temp_v0 > 0) {
        if (temp_v0 > 0) {
            phi_s4 = &sp48;
            phi_s3 = temp_v0;
loop_3:
            temp_v0_2 = *phi_s4;
            temp_a2 = *(&D_8003F68C + (temp_v0_2 & 0x7F));
            if (0xA == temp_v0_2) {
                D_8003F86C = 0x1E;
                D_8003F870 = D_8003F870 + 0xA;
            } else {
                if (temp_a2 != 0xFF) {
                    crash_screen_draw_glyph(D_8003F86C, D_8003F870, temp_a2);
                }
                temp_t0 = D_8003F86C + 6;
                D_8003F86C = temp_t0;
                if ((gCurrScreenWidth - 0x1E) < temp_t0) {
                    D_8003F86C = 0x1E;
                    D_8003F870 = D_8003F870 + 0xA;
                }
            }
            temp_s3 = phi_s3 - 1;
            phi_s4 = phi_s4 + 1;
            phi_s3 = temp_s3;
            if (temp_s3 != 0) {
                goto loop_3;
            }
        }
    }
    osWritebackDCacheAll();
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022A58.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c
void func_80022B88(s32 arg0, ? arg1, ? arg2, ? arg3) {
    func_80022A58((s32) (sp + 0x27) & -4);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022B88.s")
#endif


extern OSThread *(*D_80096EF8)(void);
extern u8 D_8003F688;
extern OSMesgQueue *D_80096ED8;
#ifdef MIPS_TO_C
void func_80022BC4(s32 arg) {
// void thread_crash_screen(UNUSED void *arg) {
    OSMesg mesg;
    OSThread *thread;
    OSThread *temp_s0;

    osSetEventMesg(OS_EVENT_CPU_BREAK, &D_80096ED8, (OSMesg) 1);
    osSetEventMesg(OS_EVENT_FAULT, &D_80096ED8, (OSMesg) 2);
    do {
        osRecvMesg(&D_80096ED8, &mesg, 1);
        thread = get_crashed_thread();
    } while (thread == NULL);


    D_8003F688 = 1;
    func_80022248(0, 0);
    func_80022248(0x2030, 0);
    func_80022248(0, 0);
    func_80022248(0x808, 0);
    func_80022248(0, 0);
    func_80022248(0x8200, 0);
    func_80022248(0, 0);
    func_80022248(0x4100, 0);
    func_80022248(0, 0);
    func_80022248(0x404, 0);
    func_800222C4(thread, 1);
    while (D_80096EF8) {
        func_80022248(0, 0);
        func_80022248(0x2030, 0);
        crash_screen_draw_rect(0x19, 0x14, 0x10E, 0xD2);
        func_80022A44(0x1E, 0x19);
        temp_s0 = D_80096EF8();
        func_80022248(0, 0);
        func_80022248(0x2030, 0);
        if (temp_s0) {
            func_800222C4(temp_s0, 0);
            func_80022248(0, 0);
            func_80022248(0x2030, 0);
        }
        func_800222C4(thread, 0);
    }
    for (;;) {
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022BC4.s")
#endif

#ifdef MIPS_TO_C
// generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80022D98(void) {
    osCreateMesgQueue(&D_80096ED8, &D_80096EF0, 1);
    osCreateThread(&D_80096528, 8, &D_80022BC4, NULL, &D_80096ED8, 0xFA);
    osStartThread(&D_80096528);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022D98.s")
#endif

#ifdef MIPS_TO_C
// generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80022E04(s32 arg0) {
    ? sp4C;
    OSThread *temp_s0;
    OSThread *temp_v0_2;
    s32 temp_s2;
    s32 temp_s4;
    s32 temp_v0;
    s32 phi_s4;
    s32 phi_s0;
    s32 phi_s0_2;

    func_800009E8(&D_80096F00, &D_80096F10, &D_80096F08, 1);
    phi_s4 = sp48;
    phi_s0_2 = 0;
loop_1:
    osRecvMesg(&D_80096F10, &sp4C, 1);
    if (D_8003F688 != 0) {
        goto loop_1;
    }
    temp_v0 = D_8003DCA4;
    if (phi_s4 == temp_v0) {
        phi_s0 = phi_s0_2 + 1;
    } else {
        phi_s0 = 0;
    }
    temp_s4 = temp_v0;
    phi_s4 = temp_s4;
    phi_s0_2 = phi_s0;
    if (phi_s0 < 0x12C) {
        goto loop_1;
    }
    D_8003F688 = 1;
    temp_s2 = osGetThreadPri(NULL);
    osSetThreadPri(NULL, 0xFA);
    func_80022248(0, 0);
    func_80022248(0x2030, 0);
    func_80022248(0, 0);
    func_80022248(0x808, 0);
    func_80022248(0, 0);
    func_80022248(0x8200, 0);
    func_80022248(0, 0);
    func_80022248(0x4100, 0);
    func_80022248(0, 0);
    func_80022248(0x404, 0);
    func_800222C4(&gMainThread, 2);
    if (D_80096EF8 != 0) {
        func_80022248(0, 0);
        func_80022248(0x2030, 0);
        crash_screen_draw_rect(0x19, 0x14, 0x10E, 0xD2);
        func_80022A44(0x1E, 0x19);
        temp_v0_2 = D_80096EF8();
        temp_s0 = temp_v0_2;
        if (temp_v0_2 != 0) {
            func_80022248(0, 0);
            func_80022248(0x2030, 0);
            func_800222C4(temp_s0, 0);
        }
    }
    func_80022248(0, 0);
    func_80022248(0x2030, 0);
    osSetThreadPri(NULL, temp_s2);
    D_8003F688 = 0;
    phi_s4 = temp_s4;
    phi_s0_2 = 0;
    goto loop_1;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022E04.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c
void func_80023048(void) {
    osCreateThread(&D_80096F28, 8, &D_80022E04, 0, &D_800978D8, 0x69);
    osStartThread(&D_80096F28);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80023048.s")
#endif

#ifdef MIPS_TO_C
// generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void fatal_printf(s32 arg0, ? arg1, ? arg2, ? arg3) {
    s32 sp20;
    s32 temp_s0;

    D_8003F688 = 1;
    sp20 = osGetThreadPri(NULL);
    osSetThreadPri(NULL, 0xFA);
    func_80022248(0, 0);
    func_80022248(0x2030, 0);
    func_80022248(0, 0);
    func_80022248(0x808, 0);
    func_80022248(0, 0);
    func_80022248(0x8200, 0);
    func_80022248(0, 0);
    func_80022248(0x4100, 0);
    func_80022248(0, 0);
    func_80022248(0x404, 0);
loop_1:
    temp_s0 = osViGetCurrentFramebuffer();
    crash_screen_draw_rect(0x19, 0x14, 0x10E, 0x19);
    func_80022A44(0x1E, 0x19);
    func_80022A58(arg0, (sp + 0x2F) & -4);
    if (func_80022248(0, temp_s0) != 0) {
        goto loop_1;
    }
    if (func_80022248(0x2030, temp_s0) != 0) {
        goto loop_1;
    }
    osSetThreadPri(NULL, sp20);
    D_8003F688 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/fatal_printf.s")
#endif

#ifdef MIPS_TO_C
// generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800231F0(void *arg0) {
    s32 sp24;
    s32 temp_s0;

    D_8003F688 = 1;
    sp24 = osGetThreadPri(NULL);
    osSetThreadPri(NULL, 0xFA);
loop_1:
    temp_s0 = osViGetCurrentFramebuffer();
    crash_screen_draw_rect(0x19, 0x14, 0x10E, 0xD2);
    func_80022A44(0x1E, 0x19);
    arg0();
    if (func_80022248(0, temp_s0) != 0) {
        goto loop_1;
    }
    if (func_80022248(0x2030, temp_s0) != 0) {
        goto loop_1;
    }
    osSetThreadPri(NULL, sp24);
    D_8003F688 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_800231F0.s")
#endif
