#include <ultra64.h>
#include <macros.h>
#include "D_8004A7C4.h"
#include "types.h"

void load_overlay(u32 ovl);

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A28C0(void *arg0) {
    func_80022B88_ovl1(&D_800D5A70, arg0->unk0);
    func_80022B88_ovl1(&D_800D5A7C, arg0->unk2C);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A28C0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
Failed to decompile function func_800A2904:

Unable to determine jump table for jr instruction.

There must be a read of a variable in the same block as
the instruction, which has a name starting with "jtbl".
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A2904.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A2B9C(void) {
    u8 temp_a0;
    void *temp_v0;
    void *phi_v0;
    void *phi_v1;

    D_800D6B18 = 1;
    phi_v0 = &D_800D6B00;
    phi_v1 = &D_800BE3F0;
loop_1:
    temp_a0 = *phi_v1;
    if (*phi_v0 != temp_a0) {
        D_800D6B18 = 0;
    }
    temp_v0 = phi_v0 + 1;
    temp_v0->unk-1 = temp_a0;
    phi_v0 = temp_v0;
    phi_v1 = phi_v1 + 1;
    if (temp_v0 != &D_800D6B10) {
        goto loop_1;
    }
    func_80018A94_ovl1(0x3039, &D_800D6B18, &D_800D6B10);
    func_80002B88_ovl1();
    D_800BE4F0 = 1;
    D_800BE4F8 = 0;
    D_800D6F3C = 0;
    D_800D6B44 = -1;
    D_800D6B48 = -1;
    D_800D6F54 = -1;
    func_800BB24C_ovl1();
    func_800208A0_ovl1(2);
    func_800A74B0_ovl1();
    func_80022A38_ovl1(&D_800A2904);
    func_800046D0_ovl1(0x3C);
    func_800B8700_ovl1();
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A2B9C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A2C80(void) {
    func_800BB3F0_ovl1();
    func_80002B88_ovl1();
    func_80020998_ovl1(0, 0x7800);
    func_80020CC4_ovl1(0x7800);
    func_800A41B0_ovl1(0x3F800000);
    func_80004674_ovl1(0x10, 2);
    D_800D6EC8 = 0;
    func_800BB418_ovl1();
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A2C80.s")
#endif

extern s32 D_800D6B88;
extern s32 gKirbyLives;
extern f32 gKirbyHp;
extern s32 D_800D6E54;
extern f32 D_800D6E58;
extern f32 D_800D6E5C;
extern s32 D_800D6E60;
extern s32 D_800D6B7C;
extern s32 D_800D6B80;
extern s32 D_800D6B44;
extern s32 D_800D6F50;
extern s32 D_800EC9FC;

void func_800A2CE4(void) {
    D_800D6B88 = D_800EC9FC;
    gKirbyLives = 3;
    gKirbyHp = 6.0f;
    D_800D6E54 = 0;
    D_800D6E58 = 0.0f;
    D_800D6E5C = 0.0f;
    D_800D6E60 = 0;
    D_800D6B7C = 0;
    D_800D6B80 = 0;
    D_800D6B44 = -1;
    D_800D6F50 = 0;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A2D5C(void) {
    D_800D6B9C = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A2D5C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800A2D68(void) {
    s32 temp_t4;
    s32 temp_t6;
    u32 temp_v0;
    void *temp_v0_2;
    void *temp_v1;
    u32 phi_v0;
    void *phi_v0_2;
    void *phi_v1;

    D_800BE518 = 0;
    D_800BE4FC = 0;
    D_800BE51C = 0;
    D_800BE508 = 0;
    D_800BE520 = 0;
    D_800BE50C = 0;
    D_800BE524 = 0.0f;
    D_800BE510 = D_800BE524;
    D_800D6F4C = 0;
    D_800D6E64 = 0;
    D_800D6E48 = 0;
    phi_v0 = &D_800D6D10;
loop_1:
    temp_v0 = phi_v0 + 4;
    temp_v0->unk-4 = 0;
    phi_v0 = temp_v0;
    if (temp_v0 < &D_800D6E10) {
        goto loop_1;
    }
    phi_v0_2 = &D_800D6E20;
    phi_v1 = &D_800D6E30;
loop_3:
    temp_v1 = phi_v1 + 4;
    phi_v0_2->unk1 = 0;
    temp_v1->unk-3 = 0;
    phi_v0_2->unk2 = 0;
    temp_v1->unk-2 = 0;
    phi_v0_2->unk3 = 0;
    temp_v1->unk-1 = 0;
    temp_v0_2 = phi_v0_2 + 4;
    temp_v0_2->unk-4 = 0;
    temp_v1->unk-4 = 0;
    phi_v0_2 = temp_v0_2;
    phi_v1 = temp_v1;
    if (temp_v1 != &D_800D6E40) {
        goto loop_3;
    }
    D_800D6B48 = 0x22;
    func_8011C87C_ovl1(&D_800D6E40, &D_800BE51C, &D_800BE520, &D_800BE524);
    temp_t4 = D_800D6B98;
    D_800BE52C = temp_t4;
    temp_t6 = D_800D6B9C;
    D_800BE500 = temp_t4;
    D_800BE530 = temp_t6;
    D_800BE504 = temp_t6;
    return &D_800BE52C;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A2D68.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800A2E98(void) {
    s32 temp_f18;
    u32 temp_v0;
    u32 temp_v0_2;
    u32 temp_v0_3;
    u32 phi_v0;
    u32 phi_v0_2;
    u32 phi_v0_3;

    D_800D6E88 = gKirbyLives;
    D_800D6E8C = gKirbyHp;
    D_800D6E90 = D_800D6E54;
    D_800D6E98 = D_800D6E60;
    D_800D6E5C = 0.0f;
    D_800D6E58 = D_800D6E5C;
    temp_f18 = D_800D6E58;
    D_800D6E9C = temp_f18;
    D_800D6E94 = temp_f18;
    D_800D6B54 = 0;
    D_800D7090 = -1;
    func_8011C8D0_ovl1(-1, &D_800D6E9C);
    D_800BE4F8 = 1;
    D_800BE544 = -0x1E;
    phi_v0 = &D_800D7098;
loop_1:
    temp_v0 = phi_v0 + 4;
    temp_v0->unk-4 = 0;
    phi_v0 = temp_v0;
    if (temp_v0 < &D_800D70D8) {
        goto loop_1;
    }
    phi_v0_2 = &D_800D70D8;
loop_3:
    temp_v0_2 = phi_v0_2 + 4;
    temp_v0_2->unk-4 = 0.0f;
    phi_v0_2 = temp_v0_2;
    if (temp_v0_2 < &D_800D7118) {
        goto loop_3;
    }
    phi_v0_3 = &D_800D7118;
loop_5:
    temp_v0_3 = phi_v0_3 + 4;
    temp_v0_3->unk-4 = -1;
    phi_v0_3 = temp_v0_3;
    if (temp_v0_3 < &D_800D7158) {
        goto loop_5;
    }
    D_800D6E10 = 0;
    D_800D7088 = 0;
    D_800EC9E4 = 0.0f;
    D_800D6E40 = 0;
    D_800D6E44 = 0;
    D_800D6E1C = 0;
    D_800D6E18 = 0;
    D_800D6E14 = 0;
    D_800D6E78 = 0;
    D_800D6E68 = 0;
    D_800D6E7C = 0;
    D_800D6E6C = 0;
    D_800D6E80 = 0;
    D_800D6E70 = 0;
    D_800D6E84 = 0;
    D_800D6E74 = 0;
    return &D_800D6E40;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A2E98.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800A3058(void) {
    s32 temp_v0;
    void *temp_v0_2;
    void *phi_v0;
    void *phi_return;

    temp_v0 = D_80000300;
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {
            load_overlay(2);
            func_80151CEC_ovl1(5);
        }
    }
    D_80004624_ovl1();
    D_80004624_ovl1();
    phi_v0 = &D_80048E9C;
loop_4:
    temp_v0_2 = phi_v0 + 1;
    phi_return = temp_v0_2;
    if (-1 == *phi_v0) {
        phi_v0 = temp_v0_2;
        if (temp_v0_2 != &D_80048EA0) {
            goto loop_4;
        }
        load_overlay(2);
        phi_return = func_80151CEC_ovl1(4);
    }
    return phi_return;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A3058.s")
#endif

void func_800A30E8(void) {
    load_overlay(19);
    tamper_check_ovl20();
    load_overlay(5);
    load_overlay(6);
    load_overlay(17);
}

void func_800A3128(void) {
    load_overlay(2);
    load_overlay(3);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A3150(s32 arg0) {
    D_800D6F38 = 0;
    D_800D6F3C = arg0;
    D_800D6B8C = D_800D6B88;
    D_800D6B88 = -1;
    func_800A2C80_ovl1();
    func_800A2CE4();
    func_800A2D5C_ovl1();
    func_800A2D68_ovl1();
    load_overlay(0x12);
    func_800BBBA0_ovl1();
    while (D_800D6F38 != 0 && D_800BE4F8 != 0) {
        func_800A30E8_ovl1();
        func_800A2E98_ovl1();
        func_800F6AD4_ovl1(1);
        func_80020C88_ovl1();
    }
    D_800D6B88 = D_800D6B8C;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A3150.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A3228(void) {

}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A3228.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A3230(void) {
    s32 temp_s0;
    void *temp_v0;
    s32 phi_s0;

    if (D_800BE500 == 0) {
        phi_s0 = 0;
loop_2:
        temp_v0 = (&D_800BE400 + (D_800BE504 * 6)) + phi_s0;
        if (D_800BE508 == temp_v0->unk0) {
            if (D_800BE534 == temp_v0->unk1) {
                if (func_800B9F50_ovl1(temp_v0->unk2) == 0) {
                    func_800A74D8_ovl1();
                    func_800B9F90_ovl1(((&D_800BE400 + (D_800BE504 * 6)) + phi_s0)->unk2, D_800D6B88);
                    func_800B9C50_ovl1(D_800D6B88);
                    load_overlay(4);
                    func_80154D60_ovl1(((&D_800BE400 + (D_800BE504 * 6)) + phi_s0)->unk2, 2);
                }
            }
        }
        temp_s0 = phi_s0 + 3;
        phi_s0 = temp_s0;
        if (temp_s0 != 6) {
            goto loop_2;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A3230.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
s32 func_800A336C(void) {
    s32 temp_ret;
    s32 temp_v0;
    s32 phi_return;

    temp_v0 = D_800BE500;
    phi_return = temp_v0;
    if (temp_v0 >= 0) {
        phi_return = temp_v0;
        if (temp_v0 < 5) {
            temp_ret = func_800B9F50_ovl1(*(&D_800BE414 + (temp_v0 * 4)));
            phi_return = temp_ret;
            if (temp_ret == 0) {
                func_800B9F90_ovl1(*(&D_800BE414 + (D_800BE500 * 4)), D_800D6B88);
                func_800B9C50_ovl1(D_800D6B88);
                load_overlay(4);
                phi_return = func_80154D60_ovl1(*(&D_800BE414 + (D_800BE500 * 4)), 2);
            }
        }
    }
    return phi_return;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A336C.s")
#endif


#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A3408(void) {
    if (1 == D_800D6B90) {
        if (1 == D_800D6B94) {
            load_overlay(0x12);
            if (func_80227308_ovl1(0) != 0) {
                D_800BE4F4 = D_800BE4F0;
loop_4:
                D_800BE4F0 = 0xE;
                func_800A3150_ovl1(4);
                load_overlay(0x12);
                if (func_80227308_ovl1(1) == 1) {
                    goto loop_4;
                }
                func_800A2CE4();
                func_800B96A0_ovl1(D_800D6B88, 0);
                D_800BE4F0 = D_800BE4F4;
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A3408.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
f32 func_800A34C8(void) {
    void *phi_s0;
    void *phi_v1;
    f32 phi_return;

    D_800D6B6C = 2;
    gKirbyLives = 1;
    gKirbyHp = 6.0f;
    D_800D6E54 = 0;
    D_800D6E58 = 0.0f;
    D_800D6E5C = 0.0f;
    D_800D6E60 = 0;
    D_800D6B7C = 0;
    D_800D6B80 = 0;
    D_800D6B44 = -1;
    phi_v1 = &D_800D6B6C;
    phi_return = 0.0f;
    if (-1 != D_800BE438) {
        phi_s0 = &D_800BE438;
loop_2:
        func_800A30E8_ovl1();
        func_800A2D5C_ovl1();
        D_800D6B98 = phi_s0->unk0;
        D_800D6B9C = phi_s0->unk4;
        func_800A2D68_ovl1();
        D_800BE4FC = 1;
        D_800BE518 = 1;
        D_800D6F3C = 0;
        D_800BE534 = phi_s0->unk8;
        func_800BBBA0_ovl1();
        func_800A2C80_ovl1();
        func_800A2E98_ovl1();
        func_800F6AD4_ovl1(1);
        if (D_800BE4F8 != 6) {
            if (1 == D_800D6B6C) {
block_4:
                D_800D6B6C = 1;
            } else {
                phi_s0 = phi_s0 + 0xC;
                if (-1 != phi_s0->unkC) {
                    goto loop_2;
                }
            }
        } else {
            goto block_4;
        }
        phi_v1 = &D_800D6B6C;
        phi_return = func_800A74D8_ovl1();
    }
    if (*phi_v1 == 2) {
        if (6.0f == gKirbyHp) {
            *phi_v1 = 3;
        }
    }
    D_800BE4F0 = 0x1A;
    return phi_return;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A34C8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800A36C0(void) {
    ? sp70;
    ? sp2C;
    ? *temp_s0;
    ? *temp_t6;
    void *temp_t7;
    void *phi_t7;
    ? *phi_t6;
    ? *phi_s0;

    phi_t7 = &D_800BE498;
    phi_t6 = &sp2C;
loop_1:
    temp_t7 = phi_t7 + 0xC;
    temp_t6 = phi_t6 + 0xC;
    temp_t6->unk-C = *phi_t7;
    temp_t6->unk-8 = temp_t7->unk-8;
    temp_t6->unk-4 = temp_t7->unk-4;
    phi_t7 = temp_t7;
    phi_t6 = temp_t6;
    if (temp_t7 != (&D_800BE498 + 0x3C)) {
        goto loop_1;
    }
    temp_t6->unk0 = temp_t7->unk0;
    temp_t6->unk4 = temp_t7->unk4;
    phi_s0 = &sp2C;
loop_3:
    load_overlay(4);
    temp_s0 = phi_s0 + 4;
    if (func_80154D60_ovl1(*phi_s0, 0x15) != 3) {
        phi_s0 = temp_s0;
        if (temp_s0 != &sp70) {
            goto loop_3;
        }
    }
    D_800D6B68 = D_800BE4F0;
    D_800BE4F0 = 0x17;
    return &D_800BE4F0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A36C0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
Failed to decompile function func_800A377C:

Unable to determine jump table for jr instruction.

There must be a read of a variable in the same block as
the instruction, which has a name starting with "jtbl".
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A377C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A41B0(f32 arg0) {
    D_800D6B10 = arg0;
    D_800D6B14 = 1.0f / arg0;
    func_800075DC_ovl1(arg0 & 0xFFFF, 1);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A41B0.s")
#endif

void print_error_stub(char* arg0, ...) {

}

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
? func_800A428C(s32 arg0, void *arg1, s32 arg2) {
    ? sp48;
    ? *temp_s0;
    ? *temp_s0_2;
    ? *temp_s1;
    ? *temp_s1_2;
    s32 temp_s5;
    s32 temp_t0;
    s32 temp_t1;
    s32 temp_t2;
    u8 temp_v0;
    void *phi_s6;
    ? *phi_s1;
    ? *phi_s1_2;
    s32 phi_t2;
    ? *phi_s1_3;
    ? *phi_s0;
    s32 phi_s5;
    ? *phi_s1_4;
    ? *phi_s0_2;
    ? *phi_s1_5;

    phi_s1_4 = &sp48;
    if (arg2 > 0) {
        phi_s6 = arg1;
        phi_s1 = &sp48;
        phi_s5 = 0;
loop_2:
        temp_v0 = *phi_s6;
        phi_s1_2 = phi_s1;
        if (temp_v0 != 9) {
            if (temp_v0 != 0xA) {
                temp_s1 = phi_s1 + 1;
                D_800BE5C0 = D_800BE5C0 + 1;
                temp_s1->unk-1 = temp_v0;
                phi_s1_3 = temp_s1;
            } else {
                *phi_s1 = 0xA;
                D_800BE5C0 = 0;
                phi_s1_3 = phi_s1 + 1;
            }
        } else {
loop_6:
            *phi_s1_2 = 0x20;
            temp_s1_2 = phi_s1_2 + 1;
            temp_t0 = D_800BE5C0 + 1;
            temp_t1 = temp_t0;
            D_800BE5C0 = temp_t0;
            temp_t2 = temp_t1 & 7;
            phi_t2 = temp_t2;
            if (temp_t1 < 0) {
                phi_t2 = temp_t2;
                if (temp_t2 != 0) {
                    phi_t2 = temp_t2 - 8;
                }
            }
            phi_s1_2 = temp_s1_2;
            phi_s1_3 = temp_s1_2;
            if (phi_t2 != 0) {
                goto loop_6;
            }
        }
        if (0xA != temp_v0) {
            phi_s1_5 = phi_s1_3;
            if ((phi_s1_3 - &sp48) >= 0x65) {
block_12:
                func_800A4414_ovl1(((phi_s1_3 - &sp48) - 1) & 0xFF);
                phi_s0 = &sp48;
                if (phi_s1_3 != &sp48) {
loop_13:
                    temp_s0 = phi_s0 + 1;
                    func_800A4414_ovl1(*phi_s0);
                    phi_s0 = temp_s0;
                    if (temp_s0 != phi_s1_3) {
                        goto loop_13;
                    }
                }
                phi_s1_5 = &sp48;
            }
        } else {
            goto block_12;
        }
        temp_s5 = phi_s5 + 1;
        phi_s6 = phi_s6 + 1;
        phi_s1 = phi_s1_5;
        phi_s5 = temp_s5;
        phi_s1_4 = phi_s1_5;
        if (temp_s5 != arg2) {
            goto loop_2;
        }
    }
    if (phi_s1_4 != &sp48) {
        func_800A4414_ovl1(((phi_s1_4 - &sp48) - 1) & 0xFF);
        phi_s0_2 = &sp48;
        if (phi_s1_4 != &sp48) {
loop_18:
            temp_s0_2 = phi_s0_2 + 1;
            func_800A4414_ovl1(*phi_s0_2);
            phi_s0_2 = temp_s0_2;
            if (temp_s0_2 != phi_s1_4) {
                goto loop_18;
            }
        }
    }
    return 1;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A428C.s")
#endif

extern u32 *D_800BE5CC, *D_800BE5C4;
extern u32 *D_800BE5C8;

#ifdef MIPS_TO_C
void func_800A4414(u8 arg0) {
    while ((*D_800BE5CC & 3) != 0) *D_800BE5CC &= 3;
    while ((*D_800BE5C4 & 4) == 0) *D_800BE5C4 &= 4;
    *D_800BE5C8 = arg0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A4414.s")
#endif


// executes a set of (arg1 - arg0) callback functions
void func_800A447C(u32 arg0, u32 arg1, void (*callback[])(struct UnkStruct8004A7C4 *a1)) {
    if (arg0 < arg1) callback[arg0](D_8004A7C4);
}

extern f32 D_800D5C30;
f32 vec3_dot_product(Vector *arg0, Vector *arg1) {
    f32 dotProduct;
    f32 dotProductMag;

    dotProduct = (arg0->x * arg1->x) + (arg0->y * arg1->y) + (arg0->z * arg1->z);
    dotProductMag = ABSF(dotProduct);
    if (D_800D5C30 < dotProductMag) { // denorm check; D_800D5C30 = 0.00001f
        return dotProduct;
    }
    return 0.0f;
}

f32 vec3_mag_square(Vector *arg0) {
    f32 x = arg0->x;
    f32 y = arg0->y;
    f32 z = arg0->z;
    return (x * x) + (y * y) + (z * z);
}

f32 vec3_dist_square(Vector *v1, Vector *v2) {
    f32 x2 = v2->x - v1->x;
    f32 y2 = v2->y - v1->y;
    f32 z2 = v2->z - v1->z;
    return (x2 * x2) + (y2 * y2) + (z2 * z2);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
f32 func_800A4598(void *arg0) {
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 phi_f12;

    temp_f0_2 = arg0->unk0;
    if (temp_f0_2 < 0.0f) {
        temp_f12 = D_800D5C38;
        arg0->unk0 = temp_f0_2 + temp_f12;
        phi_f12 = temp_f12;
    } else {
        temp_f12_2 = D_800D6B2A;
        phi_f12 = temp_f12_2;
        if (temp_f12_2 <= temp_f0_2) {
            arg0->unk0 = temp_f0_2 - temp_f12_2;
            phi_f12 = temp_f12_2;
        }
    }
    temp_f0_3 = arg0->unk4;
    if (temp_f0_3 < 0.0f) {
        arg0->unk4 = temp_f0_3 + phi_f12;
    } else {
        if (phi_f12 <= temp_f0_3) {
            arg0->unk4 = temp_f0_3 - phi_f12;
        }
    }
    temp_f0 = arg0->unk8;
    if (temp_f0 < 0.0f) {
        arg0->unk8 = temp_f0 + phi_f12;
        return temp_f0;
    }
    if (phi_f12 <= temp_f0) {
        arg0->unk8 = temp_f0 - phi_f12;
    }
    return temp_f0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A4598.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A465C(void *arg0, ? arg1, f32 arg2, f32 arg3) {
    f32 sp40;
    f32 sp3C;
    f32 sp34;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f20;
    f32 temp_f22;
    f32 temp_f2;
    f32 temp_f4;

    temp_f20 = sinf(arg1);
    temp_f22 = cosf(arg1);
    sp40 = sinf(arg2);
    sp34 = cosf(arg2);
    sp3C = sinf(arg3);
    temp_f0 = cosf(arg3);
    temp_f4 = temp_f0 * sp34;
    arg0->unk20 = sp40;
    temp_f2 = temp_f0 * sp40;
    arg0->unk0 = temp_f4;
    arg0->unk4 = (sp3C * temp_f22) + (temp_f2 * temp_f20);
    arg0->unk38 = 0.0f;
    arg0->unk34 = 0.0f;
    arg0->unk30 = 0.0f;
    arg0->unk2C = 0.0f;
    temp_f12 = sp3C * sp40;
    arg0->unk8 = (sp3C * temp_f20) - (temp_f2 * temp_f22);
    arg0->unk1C = 0.0f;
    arg0->unk10 = -sp3C * sp34;
    arg0->unkC = 0.0f;
    arg0->unk14 = (temp_f0 * temp_f22) - (temp_f12 * temp_f20);
    arg0->unk18 = (temp_f0 * temp_f20) + (temp_f12 * temp_f22);
    arg0->unk24 = -sp34 * temp_f20;
    arg0->unk3C = 1.0f;
    arg0->unk28 = sp34 * temp_f22;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A465C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800A4794(void *arg0, void *arg1) {
    ? sp80;
    ? sp40;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    void *temp_s0;
    void *phi_s0;

    phi_s0 = arg1;
    if (arg1 == 0) {
        phi_s0 = D_8004A7C4[0xF];
    }
    func_80030C10_ovl1(&sp80);
loop_3:
    temp_f0 = phi_s0->unk40;
    if (1.0f == temp_f0) {
        if (1.0f == phi_s0->unk44) {
            if (1.0f != phi_s0->unk48) {
block_6:
                func_8001B4AC_ovl1(&sp40, temp_f0, (bitwise s32) phi_s0->unk44, (bitwise s32) phi_s0->unk48);
                guMtxCatF(&sp80, &sp40, &sp80);
            }
        } else {
            goto block_6;
        }
    } else {
        goto block_6;
    }
    temp_f0_2 = phi_s0->unk30;
    if (0.0f == temp_f0_2) {
        if (0.0f == phi_s0->unk34) {
            if (0.0f != phi_s0->unk38) {
block_10:
                guRotateRPYF(&sp40, temp_f0_2, (bitwise s32) phi_s0->unk34, (bitwise s32) phi_s0->unk38);
                guMtxCatF(&sp80, &sp40, &sp80);
            }
        } else {
            goto block_10;
        }
    } else {
        goto block_10;
    }
    temp_f0_3 = phi_s0->unk1C;
    if (0.0f == temp_f0_3) {
        if (0.0f == phi_s0->unk20) {
            if (0.0f != phi_s0->unk24) {
block_14:
                func_8001B6E4_ovl1(&sp40, temp_f0_3, (bitwise s32) phi_s0->unk20, (bitwise s32) phi_s0->unk24);
                guMtxCatF(&sp80, &sp40, &sp80);
            }
        } else {
            goto block_14;
        }
    } else {
        goto block_14;
    }
    temp_s0 = phi_s0->unk14;
    phi_s0 = temp_s0;
    if (temp_s0 != 1) {
        goto loop_3;
    }
    arg0->unk0 = spB0;
    arg0->unk4 = spB4;
    arg0->unk8 = spB8;
    return arg0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A4794.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A4958(s32 arg0, void *arg1, void *arg2) {
    ? sp90;
    ? sp50;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    void *temp_s0;
    void *phi_s0;

    phi_s0 = arg1;
    if (arg1 == 0) {
        phi_s0 = D_8004A7C4[0xF];
    }
    func_80030C10_ovl1(&sp90);
loop_3:
    temp_f0 = phi_s0->unk40;
    if (1.0f == temp_f0) {
        if (1.0f == phi_s0->unk44) {
            if (1.0f != phi_s0->unk48) {
block_6:
                func_8001B4AC_ovl1(&sp50, temp_f0, (bitwise s32) phi_s0->unk44, (bitwise s32) phi_s0->unk48);
                guMtxCatF(&sp90, &sp50, &sp90);
            }
        } else {
            goto block_6;
        }
    } else {
        goto block_6;
    }
    temp_f0_2 = phi_s0->unk30;
    if (0.0f == temp_f0_2) {
        if (0.0f == phi_s0->unk34) {
            if (0.0f != phi_s0->unk38) {
block_10:
                guRotateRPYF(&sp50, temp_f0_2, (bitwise s32) phi_s0->unk34, (bitwise s32) phi_s0->unk38);
                guMtxCatF(&sp90, &sp50, &sp90);
            }
        } else {
            goto block_10;
        }
    } else {
        goto block_10;
    }
    temp_f0_3 = phi_s0->unk1C;
    if (0.0f == temp_f0_3) {
        if (0.0f == phi_s0->unk20) {
            if (0.0f != phi_s0->unk24) {
block_14:
                func_8001B6E4_ovl1(&sp50, temp_f0_3, (bitwise s32) phi_s0->unk20, (bitwise s32) phi_s0->unk24);
                guMtxCatF(&sp90, &sp50, &sp90);
            }
        } else {
            goto block_14;
        }
    } else {
        goto block_14;
    }
    temp_s0 = phi_s0->unk14;
    phi_s0 = temp_s0;
    if (temp_s0 != 1) {
        goto loop_3;
    }
    guMtxXFMF(&sp90, arg2->unk0, arg2->unk4, arg2->unk8, arg0, arg0 + 4, arg0 + 8);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A4958.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
f32 func_800A4B34(void *arg0, void *arg1) {
    f32 sp7C;
    ? sp3C;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f12;
    f32 temp_f2;
    void *temp_s0;
    void *phi_s0;

    phi_s0 = arg1;
    if (arg1 == 0) {
        phi_s0 = D_8004A7C4[0xF];
    }
    func_80030C10_ovl1(&sp7C);
loop_3:
    temp_f0_2 = phi_s0->unk40;
    if (1.0f == temp_f0_2) {
        if (1.0f == phi_s0->unk44) {
            if (1.0f != phi_s0->unk48) {
block_6:
                func_8001B4AC_ovl1(&sp3C, 1.0f / temp_f0_2, 1.0f / phi_s0->unk44, 1.0f / phi_s0->unk48);
                guMtxCatF(&sp3C, &sp7C, &sp7C);
            }
        } else {
            goto block_6;
        }
    } else {
        goto block_6;
    }
    temp_f0_3 = phi_s0->unk30;
    if (0.0f == temp_f0_3) {
        if (0.0f == phi_s0->unk34) {
            if (0.0f != phi_s0->unk38) {
block_10:
                func_800A465C_ovl1(&sp3C, -temp_f0_3, -phi_s0->unk34, -phi_s0->unk38);
                guMtxCatF(&sp3C, &sp7C, &sp7C);
            }
        } else {
            goto block_10;
        }
    } else {
        goto block_10;
    }
    temp_f0_4 = phi_s0->unk1C;
    if (0.0f == temp_f0_4) {
        if (0.0f == phi_s0->unk20) {
            if (0.0f != phi_s0->unk24) {
block_14:
                func_8001B6E4_ovl1(&sp3C, -temp_f0_4, -phi_s0->unk20, -phi_s0->unk24);
                guMtxCatF(&sp3C, &sp7C, &sp7C);
            }
        } else {
            goto block_14;
        }
    } else {
        goto block_14;
    }
    temp_s0 = phi_s0->unk14;
    phi_s0 = temp_s0;
    if (temp_s0 != 1) {
        goto loop_3;
    }
    temp_f0 = arg0->unk0;
    temp_f2 = arg0->unk4;
    temp_f12 = arg0->unk8;
    arg0->unk0 = spAC + (((sp7C * temp_f0) + (sp8C * temp_f2)) + (sp9C * temp_f12));
    arg0->unk4 = spB0 + (((sp80 * temp_f0) + (sp90 * temp_f2)) + (spA0 * temp_f12));
    arg0->unk8 = spB4 + (((sp84 * temp_f0) + (sp94 * temp_f2)) + (spA4 * temp_f12));
    return temp_f0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A4B34.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A4DB8(void *arg0, void *arg1) {
    f32 sp80;
    ? sp40;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f2;
    void *temp_s0;
    void *phi_s0;
    f32 phi_f0;

    phi_s0 = arg1;
    if (arg1 == 0) {
        phi_s0 = D_8004A7C4[0xF];
    }
    func_80030C10_ovl1(&sp80);
loop_3:
    temp_f0 = phi_s0->unk30;
    if (0.0f == temp_f0) {
        if (0.0f == phi_s0->unk34) {
            if (0.0f != phi_s0->unk38) {
block_6:
                guRotateRPYF(&sp40, temp_f0, (bitwise s32) phi_s0->unk34, (bitwise s32) phi_s0->unk38);
                guMtxCatF(&sp80, &sp40, &sp80);
            }
        } else {
            goto block_6;
        }
    } else {
        goto block_6;
    }
    temp_s0 = phi_s0->unk14;
    phi_s0 = temp_s0;
    if (temp_s0 != 1) {
        goto loop_3;
    }
    temp_f0_2 = asinf(-sp88);
    temp_f2 = D_800D5C3C;
    arg0->unk4 = temp_f0_2;
    if (temp_f0_2 != temp_f2) {
        if (D_800D5C40 == arg0->unk4) {
block_10:
            if (temp_f2 == arg0->unk4) {
                phi_f0 = atan2f(sp90, sp94);
            } else {
                phi_f0 = atan2f(-sp90, sp94);
            }
            arg0->unk0 = phi_f0;
            arg0->unk8 = 0.0f;
        } else {
            arg0->unk0 = atan2f(sp98, spA8);
            arg0->unk8 = atan2f(sp84, sp80);
        }
    } else {
        goto block_10;
    }
    func_800A4598_ovl1(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A4DB8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
f32 func_800A4F48(s32 arg0, void *arg1, f32 arg2, f32 arg3) {
    f32 sp10;
    f32 sp0;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f10;
    f32 temp_f14;
    f32 temp_f14_2;
    f32 temp_f16;
    f32 temp_f2;
    f32 phi_f0;
    f32 phi_f0_2;
    f32 phi_return;

    temp_f2 = arg1->unk0;
    temp_f14 = arg1->unk4;
    temp_f16 = arg1->unk8;
    temp_f0 = 1.0f / (D_800D6ED0.unk3C + (((D_800D6ED0.unkC * temp_f2) + (D_800D6ED0.unk1C * temp_f14)) + (D_800D6ED0.unk2C * temp_f16)));
    temp_f10 = (D_800D6ED0.unk30 + (((D_800D6ED0.unk0 * temp_f2) + (D_800D6ED0.unk10 * temp_f14)) + (D_800D6ED0.unk20 * temp_f16))) * temp_f0;
    sp0 = temp_f10;
    sp10 = D_800D6ED0.unk34 + (((D_800D6ED0.unk4 * temp_f2) + (D_800D6ED0.unk14 * temp_f14)) + (D_800D6ED0.unk24 * temp_f16));
    arg1->unk0 = sp0;
    arg1->unk4 = sp10 * temp_f0;
    if (temp_f10 < 0.0f) {
        temp_f0_2 = -arg1->unk0;
        phi_f0 = temp_f0_2;
        phi_return = temp_f0_2;
    } else {
        temp_f0_3 = arg1->unk0;
        phi_f0 = temp_f0_3;
        phi_return = temp_f0_3;
    }
    if (phi_f0 < arg2) {
        temp_f14_2 = arg1->unk4;
        if (temp_f14_2 < 0.0f) {
            temp_f0_4 = -temp_f14_2;
            phi_f0_2 = temp_f0_4;
            phi_return = temp_f0_4;
        } else {
            phi_f0_2 = temp_f14_2;
            phi_return = temp_f14_2;
        }
        if (phi_f0_2 < arg3) {
            phi_return = 1e-45.0f;
        }
    }
    return phi_return;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A4F48.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
f32 func_800A509C(s32 arg0, void *arg1, f32 arg2, f32 arg3, f32 arg4) {
    f32 sp18;
    f32 sp14;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f18;
    f32 temp_f18_2;
    f32 temp_f20;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f4;
    f32 phi_f2;
    f32 phi_f0;
    f32 phi_return;
    f32 phi_return_2;

    temp_f0 = arg1->unk0;
    temp_f2 = arg1->unk4;
    temp_f18 = arg1->unk8;
    temp_f4 = D_800D6ED0.unk34 + (((D_800D6ED0.unk4 * temp_f0) + (D_800D6ED0.unk14 * temp_f2)) + (D_800D6ED0.unk24 * temp_f18));
    sp18 = temp_f4;
    sp14 = D_800D6ED0.unk38 + (((D_800D6ED0.unk8 * temp_f0) + (D_800D6ED0.unk18 * temp_f2)) + (D_800D6ED0.unk28 * temp_f18));
    temp_f20 = 1.0f / (D_800D6ED0.unk3C + (((D_800D6ED0.unkC * temp_f0) + (D_800D6ED0.unk1C * temp_f2)) + (D_800D6ED0.unk2C * temp_f18)));
    arg1->unk0 = (D_800D6ED0.unk30 + (((D_800D6ED0.unk0 * temp_f0) + (D_800D6ED0.unk10 * temp_f2)) + (D_800D6ED0.unk20 * temp_f18))) * temp_f20;
    arg1->unk4 = temp_f4 * temp_f20;
    arg1->unk8 = sp14 * temp_f20;
    phi_return = 0.0f;
    if (arg2 != 0.0f) {
        phi_return = 0.0f;
        if (arg3 != 0.0f) {
            phi_return = 0.0f;
            if (arg4 != 0.0f) {
                temp_f0_2 = arg1->unk0;
                if (temp_f0_2 < 0.0f) {
                    phi_f2 = -temp_f0_2;
                } else {
                    phi_f2 = temp_f0_2;
                }
                phi_return = temp_f0_2;
                if (phi_f2 < arg2) {
                    temp_f2_2 = arg1->unk4;
                    if (temp_f2_2 < 0.0f) {
                        temp_f0_3 = -temp_f2_2;
                        phi_f0 = temp_f0_3;
                        phi_return_2 = temp_f0_3;
                    } else {
                        phi_f0 = temp_f2_2;
                        phi_return_2 = temp_f2_2;
                    }
                    phi_return = phi_return_2;
                    if (phi_f0 < arg3) {
                        temp_f18_2 = arg1->unk8;
                        phi_return = phi_return_2;
                        if (0.0f < temp_f18_2) {
                            phi_return = phi_return_2;
                            if (temp_f18_2 < arg4) {
                                phi_return = 1e-45.0f;
                            }
                        }
                    }
                }
            }
        }
    }
    return phi_return;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A509C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800A5268(void) {
    if (func_8012122C_ovl1() == 0) {
        D_800D6FE8.unk0 = D_80048F20.unk0;
        D_800D6FE8.unk2 = D_80048F20.unk2;
        D_800D6FE8.unk4 = D_80048F20.unk4;
        D_800D6FE8.unk6 = D_80048F20.unk6;
        D_800D6FE8.unk8 = D_80048F20.unk8;
        D_800D6FE8.unk9 = D_80048F20.unk9;
        return &D_800D6FE8;
    }
    D_800D6FE8.unk0 = 0;
    D_800D6FE8.unk2 = 0;
    D_800D6FE8.unk4 = 0;
    D_800D6FE8.unk6 = 0;
    D_800D6FE8.unk8 = 0;
    D_800D6FE8.unk9 = 0;
    return &D_800D6FE8;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A5268.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
f32 func_800A52F0(f32 arg0, f32 arg1) {
    f32 temp_f0;
    f32 temp_f14;
    f32 phi_f12;
    f32 phi_f14;
    s32 phi_v1;
    s32 phi_v0;
    s32 phi_v0_2;
    f32 phi_f14_2;
    f32 phi_f2;
    f32 phi_f2_2;
    f32 phi_f12_2;

    if (arg0 < 0.0f) {
        phi_f12 = -arg0;
    } else {
        phi_f12 = arg0;
    }
    phi_f14 = arg1;
    if (arg1 < 0.0f) {
        phi_f14 = -arg1;
    }
    temp_f0 = atan2f(phi_f12, phi_f14);
    phi_v1 = 0;
    if (arg1 < 0.0f) {
        phi_v1 = 1;
    }
    if (phi_v1 != 0) {
        phi_v0_2 = 0;
        if (arg0 < 0.0f) {
            phi_v0_2 = 1;
        }
        phi_f14_2 = D_800D5C48;
        phi_f12_2 = D_800D5C44;
    } else {
        phi_v0 = 0;
        if (arg0 < 0.0f) {
            phi_v0 = 1;
        }
        if (phi_v0 != 0) {
            temp_f14 = D_800D5C50;
            phi_v0_2 = phi_v0;
            phi_f14_2 = temp_f14;
            phi_f12_2 = temp_f14;
        } else {
            phi_v0_2 = phi_v0;
            phi_f14_2 = D_800D6B2A;
            phi_f12_2 = 0.0f;
        }
    }
    if (phi_v1 != phi_v0_2) {
        phi_f2 = phi_f12_2 - temp_f0;
    } else {
        phi_f2 = phi_f12_2 + temp_f0;
    }
    phi_f2_2 = phi_f2;
    if (phi_f14_2 < phi_f2) {
        phi_f2_2 = phi_f2 - phi_f14_2;
    }
    return phi_f2_2;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A52F0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
u8 func_800A5404(void *arg0, void *arg1) {
    u8 temp_v0;
    u8 temp_v0_2;
    u8 temp_v0_3;
    u8 temp_v0_4;
    u8 temp_v0_5;
    u8 temp_v0_6;

    temp_v0_2 = arg1->unk0;
    arg0->unk4 = temp_v0_2;
    arg0->unk0 = temp_v0_2;
    temp_v0_3 = arg1->unk1;
    arg0->unk5 = temp_v0_3;
    arg0->unk1 = temp_v0_3;
    temp_v0_4 = arg1->unk2;
    arg0->unk6 = temp_v0_4;
    arg0->unk2 = temp_v0_4;
    temp_v0_5 = arg1->unk3;
    arg0->unkC = temp_v0_5;
    arg0->unk8 = temp_v0_5;
    temp_v0_6 = arg1->unk4;
    arg0->unkD = temp_v0_6;
    arg0->unk9 = temp_v0_6;
    temp_v0 = arg1->unk5;
    arg0->unkE = temp_v0;
    arg0->unkA = temp_v0;
    arg0->unk10 = arg1->unk6;
    arg0->unk11 = arg1->unk7;
    arg0->unk12 = arg1->unk8;
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A5404.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A5468(void *arg0, void *arg1) {
    u8 temp_t1;
    u8 temp_t3;
    u8 temp_t5;
    u8 temp_t7;
    u8 temp_t9;
    u8 temp_t9_2;

    temp_t9 = arg0->unk4 + arg1->unk0;
    arg0->unk4 = temp_t9;
    arg0->unk0 = temp_t9;
    temp_t3 = arg0->unk5 + arg1->unk1;
    arg0->unk5 = temp_t3;
    arg0->unk1 = temp_t3;
    temp_t7 = arg0->unk6 + arg1->unk2;
    arg0->unk6 = temp_t7;
    arg0->unk2 = temp_t7;
    temp_t1 = arg0->unkC + arg1->unk3;
    arg0->unkC = temp_t1;
    arg0->unk8 = temp_t1;
    temp_t5 = arg0->unkD + arg1->unk4;
    arg0->unkD = temp_t5;
    arg0->unk9 = temp_t5;
    temp_t9_2 = arg0->unkE + arg1->unk5;
    arg0->unkE = temp_t9_2;
    arg0->unkA = temp_t9_2;
    arg0->unk10 = arg1->unk6;
    arg0->unk11 = arg1->unk7;
    arg0->unk12 = arg1->unk8;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A5468.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
u8 func_800A54FC(void *arg0, void *arg1) {
    u8 temp_v0;
    u8 temp_v0_2;
    u8 temp_v0_3;
    u8 temp_v0_4;
    u8 temp_v0_5;
    u8 temp_v0_6;

    temp_v0_2 = arg0->unk0;
    arg1->unk4 = temp_v0_2;
    arg1->unk0 = temp_v0_2;
    temp_v0_3 = arg0->unk1;
    arg1->unk5 = temp_v0_3;
    arg1->unk1 = temp_v0_3;
    temp_v0_4 = arg0->unk2;
    arg1->unk6 = temp_v0_4;
    arg1->unk2 = temp_v0_4;
    temp_v0_5 = arg0->unk8;
    arg1->unkC = temp_v0_5;
    arg1->unk8 = temp_v0_5;
    temp_v0_6 = arg0->unk9;
    arg1->unkD = temp_v0_6;
    arg1->unk9 = temp_v0_6;
    temp_v0 = arg0->unkA;
    arg1->unkE = temp_v0;
    arg1->unkA = temp_v0;
    arg1->unk10 = arg0->unk10;
    arg1->unk11 = arg0->unk11;
    arg1->unk12 = arg0->unk12;
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A54FC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
s8 func_800A5560(u32 arg0) {
    s8 temp_v1;
    u32 phi_a0;
    s32 phi_v1;
    s32 phi_v1_2;
    s32 phi_v1_3;
    s8 phi_v1_4;
    s32 phi_v1_5;

    phi_a0 = arg0;
    if (arg0 >= 4) {
        phi_a0 = 3;
    }
    temp_v1 = *(&D_80048F28 + (((phi_a0 * 4) + phi_a0) * 2));
    if (temp_v1 > 0) {
        phi_v1 = temp_v1;
        if (temp_v1 < 8) {
            phi_v1 = 8;
        }
        phi_v1_3 = phi_v1;
        if (phi_v1 >= 0x49) {
            phi_v1_3 = 0x48;
        }
        return phi_v1_3 - 8;
    }
    phi_v1_4 = temp_v1;
    if (temp_v1 < 0) {
        phi_v1_2 = temp_v1;
        if (temp_v1 >= -7) {
            phi_v1_2 = -8;
        }
        phi_v1_5 = phi_v1_2;
        if (phi_v1_2 < -0x48) {
            phi_v1_5 = -0x48;
        }
        phi_v1_4 = phi_v1_5 + 8;
    }
    return phi_v1_4;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A5560.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
s8 func_800A55E0(u32 arg0) {
    s8 temp_v1;
    u32 phi_a0;
    s32 phi_v1;
    s32 phi_v1_2;
    s32 phi_v1_3;
    s8 phi_v1_4;
    s32 phi_v1_5;

    phi_a0 = arg0;
    if (arg0 >= 4) {
        phi_a0 = 3;
    }
    temp_v1 = *(&D_80048F29 + (((phi_a0 * 4) + phi_a0) * 2));
    if (temp_v1 > 0) {
        phi_v1 = temp_v1;
        if (temp_v1 < 8) {
            phi_v1 = 8;
        }
        phi_v1_3 = phi_v1;
        if (phi_v1 >= 0x49) {
            phi_v1_3 = 0x48;
        }
        return phi_v1_3 - 8;
    }
    phi_v1_4 = temp_v1;
    if (temp_v1 < 0) {
        phi_v1_2 = temp_v1;
        if (temp_v1 >= -7) {
            phi_v1_2 = -8;
        }
        phi_v1_5 = phi_v1_2;
        if (phi_v1_2 < -0x48) {
            phi_v1_5 = -0x48;
        }
        phi_v1_4 = phi_v1_5 + 8;
    }
    return phi_v1_4;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A55E0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
? func_800A5660(s32 arg1, u32 arg2) {
    s32 phi_v0;
    s32 phi_v1;
    ? phi_return;

    if ((D_800BE4EC % arg2) != 0) {
        return 0;
    }
    if (arg1 != 0) {
        phi_v0 = func_800A55E0_ovl1();
    } else {
        phi_v0 = func_800A5560_ovl1();
    }
    phi_v1 = phi_v0 >> 4;
    if (phi_v0 < 0) {
        phi_v1 = (phi_v0 + 0xF) >> 4;
    }
    if (phi_v1 > 0) {
        return 1;
    }
    phi_return = 0;
    if (phi_v1 < 0) {
        phi_return = -1;
    }
    return phi_return;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A5660.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A56F4(s32 arg0, ?32 arg1, ?32 arg2, ?32 arg3, u8 arg4, u8 arg5, u8 arg6) {
    D_800D6B24 = 0;
    D_800D6B34 = arg0;
    D_800D6B38 = arg1;
    D_800D6B3C = arg2;
    D_800D6B40 = arg3;
    D_800D6B28 = arg4;
    D_800D6B29 = arg5;
    D_800D6B2A = arg6;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A56F4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
?32 func_800A5744(s8 arg0, s8 arg1, s8 arg2) {
    D_800D6B24 = 0;
    D_800D6B34 = 0xA;
    D_800D6B38 = 0xA;
    D_800D6B3C = 0x136;
    D_800D6B40 = 0xE6;
    D_800D6B28 = arg0;
    D_800D6B29 = arg1;
    D_800D6B2A = arg2;
    return 0xA;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A5744.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A57A0(s8 arg0, s8 arg1, s8 arg2) {
    D_800D6B28 = arg0;
    D_800D6B29 = arg1;
    D_800D6B2A = arg2;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A57A0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
u8 func_800A57C8(s32 arg0) {
    s16 temp_v0_2;
    u8 temp_ret;
    u8 temp_v0;

    func_8000B6BC_ovl1(1);
loop_1:
    D_800D6B2E = D_800D6B2E + D_800D6B2C;
    temp_v0_2 = D_800D6B2E;
    if (temp_v0_2 <= 0) {
        D_800D6B2E = 0;
    } else {
        if (temp_v0_2 >= 0xFF) {
            D_800D6B2E = 0xFF;
        } else {
            func_8000B6BC_ovl1(1);
            goto loop_1;
        }
    }
    D_800D6B30 = D_800D6B30 + 1;
    temp_v0 = D_800D6B2B;
    if (temp_v0 == 0) {
        D_800D6B24 = 0;
        func_8000B6BC_ovl1(1);
        func_8000A29C_ovl1(D_8004A7C4);
        return func_8000B6BC_ovl1(1);
    }
    if (temp_v0 == 1) {
        return func_8000B6BC_ovl1(1);
    }
    if (temp_v0 != 2) {
        return temp_v0;
    }
    func_8000B6BC_ovl1(1);
    func_800067B8_ovl1();
    temp_ret = func_8000B6BC_ovl1(1);
    D_800D6B24 = 0;
    return temp_ret;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A57C8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
Gfx *func_800A58E4(s32 arg0) {
    Gfx *temp_a2;
    Gfx *temp_a2_2;
    Gfx *temp_a3;
    Gfx *temp_t0;
    Gfx *temp_t1;
    Gfx *temp_t2;
    Gfx *temp_v0;
    Gfx *temp_v0_2;

    temp_a2 = gDisplayListHeads[1];
    temp_v0_2 = temp_a2 + 8;
    temp_a2->words.w0 = 0xE7000000;
    temp_a2->words.w1 = 0;
    temp_v0_2->words.w1 = 0x504340;
    temp_v0_2->words.w0 = 0xE200001C;
    temp_t0 = temp_v0_2 + 8;
    temp_t0->words.w0 = 0xFA000000;
    temp_t0->words.w1 = (((D_800D6B28 << 0x18) | ((D_800D6B29 & 0xFF) << 0x10)) | ((D_800D6B2A & 0xFF) << 8)) | (D_800D6B2F & 0xFF);
    temp_t1 = temp_t0 + 8;
    temp_t1->words.w1 = 0xFFFDF6FB;
    temp_t1->words.w0 = 0xFCFFFFFF;
    temp_t2 = temp_t1 + 8;
    temp_t2->words.w0 = (((D_800D6B3C & 0x3FF) << 0xE) | 0xF6000000) | ((D_800D6B40 & 0x3FF) * 4);
    temp_a2_2 = temp_t2 + 8;
    temp_t2->words.w1 = ((D_800D6B34 & 0x3FF) << 0xE) | ((D_800D6B38 & 0x3FF) * 4);
    temp_a3 = temp_a2_2 + 8;
    temp_a2_2->words.w1 = 0;
    temp_a2_2->words.w0 = 0xE7000000;
    temp_a3->words.w1 = 0x5049D8;
    temp_a3->words.w0 = 0xE200001C;
    temp_v0 = temp_a3 + 8;
    gDisplayListHeads[1] = temp_v0;
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A58E4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A5A14(s16 arg0, s16 arg1, u8 arg2) {
    if (D_800D6B24 == 0) {
        D_800D6B2E = arg0;
        D_800D6B2C = arg1 * D_800D6B10;
        D_800D6B2B = arg2;
        D_800D6B24 = func_8000BD3C_ovl1(2, 0, 0x19, 0x80000000, &D_800A58E4, 0, 0, 0, 0, 0, &D_800A57C8, 1, 0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A5A14.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
? func_800A5AD8(void) {
    if (D_800D6B24 == 0) {
        return 0;
    }
    D_800D6B2C = 0;
    D_800D6B2E = D_800D6B2C;
    return 1;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A5AD8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800A5B14(void *arg0, s8 arg1, s8 arg2, s8 arg3, u8 arg4) {
    void *temp_v0;

    temp_v0 = arg0->unk4C;
    temp_v0->unk14 = arg1;
    temp_v0->unk15 = arg2;
    temp_v0->unk16 = arg3;
    temp_v0->unk17 = arg4;
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A5B14.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800A5B3C(void *arg0, s8 arg1, s8 arg2, s8 arg3, u8 arg4) {
    void *temp_v0;

    temp_v0 = arg0->unk4C;
    temp_v0->unk18 = arg1;
    temp_v0->unk19 = arg2;
    temp_v0->unk1A = arg3;
    temp_v0->unk1B = arg4;
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A5B3C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
f32 func_800A5B64(f32 arg0) {
    s32 temp_v0;
    f32 phi_f2;

    temp_v0 = ((arg0 * D_800D5C54) & 0xFFF) & 0xFFFF;
    if ((temp_v0 & 0x400) != 0) {
        phi_f2 = *(&D_800BF8EC + -((temp_v0 & 0x3FF) * 4));
    } else {
        phi_f2 = (&D_800BF8EC + ((temp_v0 & 0x3FF) * 4))->unk-1710;
    }
    if ((temp_v0 & 0x800) != 0) {
        return -phi_f2;
    }
    return phi_f2;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A5B64.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
f32 func_800A5BDC(f32 arg0) {
    s32 temp_v0;
    f32 phi_f2;

    temp_v0 = (((arg0 + D_800D5C58) * D_800D5C5C) & 0xFFF) & 0xFFFF;
    if ((temp_v0 & 0x400) != 0) {
        phi_f2 = *(&D_800BF8EC + -((temp_v0 & 0x3FF) * 4));
    } else {
        phi_f2 = (&D_800BF8EC + ((temp_v0 & 0x3FF) * 4))->unk-1710;
    }
    if ((temp_v0 & 0x800) != 0) {
        return -phi_f2;
    }
    return phi_f2;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A5BDC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
f32 func_800A5C60(f32 arg0) {
    s32 temp_a0;
    s32 temp_v0;
    f32 phi_f2;
    f32 phi_f12;
    f32 phi_f2_2;
    f32 phi_f12_2;

    temp_a0 = ((arg0 * D_800D5C60) & 0xFFF) & 0xFFFF;
    if ((temp_a0 & 0x400) != 0) {
        phi_f2_2 = *(&D_800BF8EC + -((temp_a0 & 0x3FF) * 4));
    } else {
        phi_f2_2 = (&D_800BF8EC + ((temp_a0 & 0x3FF) * 4))->unk-1710;
    }
    phi_f2 = phi_f2_2;
    if ((temp_a0 & 0x800) != 0) {
        phi_f2 = -phi_f2_2;
    }
    temp_v0 = ((temp_a0 + 0x400) & 0xFFF) & 0xFFFF;
    if ((temp_v0 & 0x400) != 0) {
        phi_f12_2 = *(&D_800BF8EC + -((temp_v0 & 0x3FF) * 4));
    } else {
        phi_f12_2 = *(&D_800BE8F0 + ((temp_v0 & 0x3FF) * 4));
    }
    phi_f12 = phi_f12_2;
    if ((temp_v0 & 0x800) != 0) {
        phi_f12 = -phi_f12_2;
    }
    return phi_f2 / phi_f12;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A5C60.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A5D24(void *arg0, void *arg1) {
    arg0->unk0 = arg1->unk0;
    arg0->unkC = arg1->unkC;
    arg0->unk18 = arg1->unk18;
    arg0->unk24 = arg1->unk24;
    arg0->unk4 = arg1->unk4;
    arg0->unk10 = arg1->unk10;
    arg0->unk1C = arg1->unk1C;
    arg0->unk28 = arg1->unk28;
    arg0->unk8 = arg1->unk8;
    arg0->unk14 = arg1->unk14;
    arg0->unk20 = arg1->unk20;
    arg0->unk2C = arg1->unk2C;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A5D24.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800A5D88(void *arg0, void *arg1) {
    f32 sp3C;
    f32 sp38;
    f32 sp30;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f16;
    f32 temp_f20;
    f32 temp_f22;
    void *temp_s1;
    void *temp_v0;
    void *temp_v0_2;

    temp_f20 = func_800A5B64_ovl1(arg0->unk30);
    temp_s1 = arg0 + 0x30;
    temp_f22 = func_800A5BDC_ovl1(temp_s1->unk0);
    sp3C = func_800A5B64_ovl1(temp_s1->unk4);
    sp30 = func_800A5BDC_ovl1(temp_s1->unk4);
    sp38 = func_800A5B64_ovl1(temp_s1->unk8);
    temp_f0 = func_800A5BDC_ovl1(temp_s1->unk8);
    arg1->unk0 = sp30 * temp_f0;
    arg1->unk4 = sp30 * sp38;
    arg1->unk8 = -sp3C;
    temp_f12 = temp_f20 * sp3C;
    arg1->unkC = (temp_f12 * temp_f0) - (temp_f22 * sp38);
    arg1->unk14 = temp_f20 * sp30;
    arg1->unk10 = (temp_f12 * sp38) + (temp_f22 * temp_f0);
    temp_f12_2 = temp_f22 * sp3C;
    temp_v0_2 = arg0 + 0x40;
    arg1->unk18 = (temp_f12_2 * temp_f0) + (temp_f20 * sp38);
    arg1->unk20 = temp_f22 * sp30;
    arg1->unk1C = (temp_f12_2 * sp38) - (temp_f20 * temp_f0);
    temp_f16 = temp_v0_2->unk0;
    if (1.0f != temp_f16) {
        arg1->unk0 = arg1->unk0 * temp_f16;
        arg1->unk4 = arg1->unk4 * temp_v0_2->unk0;
        arg1->unk8 = arg1->unk8 * temp_v0_2->unk0;
    }
    temp_f0_2 = temp_v0_2->unk4;
    if (1.0f != temp_f0_2) {
        arg1->unkC = arg1->unkC * temp_f0_2;
        arg1->unk10 = arg1->unk10 * temp_v0_2->unk4;
        arg1->unk14 = arg1->unk14 * temp_v0_2->unk4;
    }
    temp_f0_3 = temp_v0_2->unk8;
    if (1.0f != temp_f0_3) {
        arg1->unk18 = arg1->unk18 * temp_f0_3;
        arg1->unk1C = arg1->unk1C * temp_v0_2->unk8;
        arg1->unk20 = arg1->unk20 * temp_v0_2->unk8;
    }
    temp_v0 = arg0 + 0x1C;
    arg1->unk24 = temp_v0->unk0;
    arg1->unk28 = temp_v0->unk4;
    arg1->unk2C = temp_v0->unk8;
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A5D88.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
f32 func_800A5F94(s32 arg0, void *arg1) {
    f32 sp48;
    f32 sp44;
    f32 sp3C;
    f32 *sp30;
    f32 *temp_v0;
    f32 *temp_v0_2;
    f32 *temp_v0_3;
    f32 *temp_v0_4;
    f32 *temp_v0_5;
    f32 *temp_v0_6;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f16;
    f32 temp_f20;
    f32 temp_f22;
    s32 temp_s1;

    temp_s1 = arg0 * 4;
    temp_v0 = temp_s1 + &D_800E4010;
    sp30 = temp_v0;
    temp_f20 = func_800A5B64_ovl1(*temp_v0);
    temp_v0_2 = &D_800E41D0[arg0];
    temp_f22 = func_800A5BDC_ovl1(*temp_v0);
    sp30 = temp_v0_2;
    sp48 = func_800A5B64_ovl1(*temp_v0_2);
    temp_f0_2 = func_800A5BDC_ovl1(*temp_v0_2);
    temp_v0_3 = temp_s1 + &D_800E4390;
    sp30 = temp_v0_3;
    sp3C = temp_f0_2;
    sp44 = func_800A5B64_ovl1(*temp_v0_3);
    temp_f0_3 = func_800A5BDC_ovl1(*temp_v0_3);
    temp_v0_4 = &D_800E4550[arg0];
    arg1->unk0 = sp3C * temp_f0_3;
    arg1->unk4 = sp3C * sp44;
    arg1->unk8 = -sp48;
    temp_f12 = temp_f20 * sp48;
    arg1->unkC = (temp_f12 * temp_f0_3) - (temp_f22 * sp44);
    arg1->unk14 = temp_f20 * sp3C;
    arg1->unk10 = (temp_f12 * sp44) + (temp_f22 * temp_f0_3);
    temp_f12_2 = temp_f22 * sp48;
    arg1->unk18 = (temp_f12_2 * temp_f0_3) + (temp_f20 * sp44);
    arg1->unk20 = temp_f22 * sp3C;
    arg1->unk1C = (temp_f12_2 * sp44) - (temp_f20 * temp_f0_3);
    temp_f16 = *temp_v0_4;
    if (1.0f != temp_f16) {
        arg1->unk0 = arg1->unk0 * temp_f16;
        arg1->unk4 = arg1->unk4 * *temp_v0_4;
        arg1->unk8 = arg1->unk8 * *temp_v0_4;
    }
    temp_v0_5 = &D_800E4710[arg0];
    temp_f0_4 = *temp_v0_5;
    if (1.0f != temp_f0_4) {
        arg1->unkC = arg1->unkC * temp_f0_4;
        arg1->unk10 = arg1->unk10 * *temp_v0_5;
        arg1->unk14 = arg1->unk14 * *temp_v0_5;
    }
    temp_v0_6 = &D_800E48D0[arg0];
    temp_f0 = *temp_v0_6;
    if (1.0f != temp_f0) {
        arg1->unk18 = arg1->unk18 * temp_f0;
        arg1->unk1C = arg1->unk1C * *temp_v0_6;
        arg1->unk20 = arg1->unk20 * *temp_v0_6;
    }
    arg1->unk24 = D_800E25D0[arg0];
    arg1->unk28 = D_800E2790[arg0];
    arg1->unk2C = D_800E2950[arg0];
    return temp_f0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A5F94.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A6208(void *arg0, void *arg1) {
    f32 spC;
    f32 sp8;
    f32 sp4;
    f32 *temp_t6;

    temp_t6 = &sp4;
    sp4 = arg0->unk24 + (((arg0->unk0 * arg1->unk0) + (arg0->unkC * arg1->unk4)) + (arg0->unk18 * arg1->unk8));
    sp8 = arg0->unk28 + (((arg0->unk4 * arg1->unk0) + (arg0->unk10 * arg1->unk4)) + (arg0->unk1C * arg1->unk8));
    spC = arg0->unk2C + (((arg0->unk8 * arg1->unk0) + (arg0->unk14 * arg1->unk4)) + (arg0->unk20 * arg1->unk8));
    arg1->unk0 = (bitwise f32) (bitwise s32) temp_t6->unk0;
    arg1->unk4 = (bitwise f32) (bitwise s32) temp_t6[1];
    arg1->unk8 = (bitwise f32) (bitwise s32) temp_t6[2];
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A6208.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A62D8(void *arg0, void *arg1, void *arg2) {
    arg0->unk0 = (arg2->unk8 * arg1->unk18) + ((arg1->unk0 * arg2->unk0) + (arg1->unkC * arg2->unk4));
    arg0->unk4 = (arg2->unk8 * arg1->unk1C) + ((arg1->unk4 * arg2->unk0) + (arg1->unk10 * arg2->unk4));
    arg0->unk8 = (arg2->unk8 * arg1->unk20) + ((arg1->unk8 * arg2->unk0) + (arg1->unk14 * arg2->unk4));
    arg0->unkC = (arg2->unk14 * arg1->unk18) + ((arg1->unk0 * arg2->unkC) + (arg1->unkC * arg2->unk10));
    arg0->unk10 = (arg2->unk14 * arg1->unk1C) + ((arg1->unk4 * arg2->unkC) + (arg1->unk10 * arg2->unk10));
    arg0->unk14 = (arg2->unk14 * arg1->unk20) + ((arg1->unk8 * arg2->unkC) + (arg1->unk14 * arg2->unk10));
    arg0->unk18 = (arg2->unk20 * arg1->unk18) + ((arg1->unk0 * arg2->unk18) + (arg1->unkC * arg2->unk1C));
    arg0->unk1C = (arg2->unk20 * arg1->unk1C) + ((arg1->unk4 * arg2->unk18) + (arg1->unk10 * arg2->unk1C));
    arg0->unk20 = (arg2->unk20 * arg1->unk20) + ((arg1->unk8 * arg2->unk18) + (arg1->unk14 * arg2->unk1C));
    arg0->unk24 = arg1->unk24 + (((arg1->unk0 * arg2->unk24) + (arg1->unkC * arg2->unk28)) + (arg1->unk18 * arg2->unk2C));
    arg0->unk28 = arg1->unk28 + (((arg1->unk4 * arg2->unk24) + (arg1->unk10 * arg2->unk28)) + (arg1->unk1C * arg2->unk2C));
    arg0->unk2C = arg1->unk2C + (((arg1->unk8 * arg2->unk24) + (arg1->unk14 * arg2->unk28)) + (arg1->unk20 * arg2->unk2C));
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A62D8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
f32 func_800A6534(void *arg0, void *arg1) {
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f16;
    f32 temp_f18;
    f32 temp_f2;

    arg0->unk0 = (arg1->unk10 * arg1->unk20) - (arg1->unk1C * arg1->unk14);
    temp_f2 = arg0->unk0;
    arg0->unkC = (arg1->unkC * arg1->unk20) - (arg1->unk18 * arg1->unk14);
    temp_f12 = arg0->unkC;
    arg0->unk18 = (arg1->unkC * arg1->unk1C) - (arg1->unk18 * arg1->unk10);
    temp_f0 = arg0->unk18;
    arg0->unk24 = (arg0->unk18 * arg1->unk2C) + ((arg1->unk24 * arg0->unk0) - (arg1->unk28 * arg0->unkC));
    arg0->unk4 = (arg1->unk4 * arg1->unk20) - (arg1->unk1C * arg1->unk8);
    arg0->unk10 = (arg1->unk0 * arg1->unk20) - (arg1->unk18 * arg1->unk8);
    arg0->unk1C = (arg1->unk0 * arg1->unk1C) - (arg1->unk18 * arg1->unk4);
    arg0->unk28 = (arg0->unk1C * arg1->unk2C) + ((arg1->unk24 * arg0->unk4) - (arg1->unk28 * arg0->unk10));
    arg0->unk8 = (arg1->unk4 * arg1->unk14) - (arg1->unk10 * arg1->unk8);
    arg0->unk14 = (arg1->unk0 * arg1->unk14) - (arg1->unkC * arg1->unk8);
    temp_f14 = arg0->unk14;
    arg0->unk20 = (arg1->unk0 * arg1->unk10) - (arg1->unkC * arg1->unk4);
    arg0->unk2C = (arg0->unk20 * arg1->unk2C) + ((arg1->unk24 * arg0->unk8) - (arg1->unk28 * temp_f14));
    temp_f18 = (arg1->unk0 * temp_f2) - (arg1->unk4 * temp_f12);
    arg0->unkC = -temp_f12;
    temp_f16 = (temp_f0 * arg1->unk8) + temp_f18;
    arg0->unk24 = -arg0->unk24;
    arg0->unk4 = -arg0->unk4;
    arg0->unk1C = -arg0->unk1C;
    arg0->unk14 = -temp_f14;
    arg0->unk2C = -arg0->unk2C;
    if (temp_f16 == 0.0f) {
loop_1:
        goto loop_1;
    }
    temp_f16 = 1.0f / temp_f16;
    arg0->unk0 = temp_f2 * temp_f16;
    arg0->unkC = arg0->unkC * temp_f16;
    arg0->unk18 = temp_f0 * temp_f16;
    arg0->unk24 = arg0->unk24 * temp_f16;
    arg0->unk4 = arg0->unk4 * temp_f16;
    arg0->unk10 = arg0->unk10 * temp_f16;
    arg0->unk1C = arg0->unk1C * temp_f16;
    arg0->unk28 = arg0->unk28 * temp_f16;
    arg0->unk8 = arg0->unk8 * temp_f16;
    arg0->unk14 = arg0->unk14 * temp_f16;
    arg0->unk20 = arg0->unk20 * temp_f16;
    arg0->unk2C = arg0->unk2C * temp_f16;
    return temp_f0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A6534.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A6820(void *arg0, void *arg1) {
    ? sp6C;
    f32 sp48;
    f32 *temp_s1;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f14;
    f32 temp_f2;
    void *temp_s0;
    void *phi_s0;
    f32 phi_f2;
    f32 *phi_s1;
    f32 phi_f0;

    phi_s0 = arg0;
    phi_s1 = &sp48;
loop_1:
    temp_f2 = phi_s0->unk0;
    temp_f14 = phi_s0->unk4;
    temp_f0 = phi_s0->unk8;
    temp_f0_2 = sqrtf((temp_f0 * temp_f0) + ((temp_f2 * temp_f2) + (temp_f14 * temp_f14)), temp_f14);
    phi_f2 = temp_f0_2;
    if (temp_f0_2 != 0.0f) {
        phi_f2 = 1.0f / temp_f0_2;
    }
    temp_s1 = phi_s1 + 0xC;
    temp_s0 = phi_s0 + 0xC;
    temp_s1->unk-C = phi_s0->unk0 * phi_f2;
    temp_s1->unk-8 = temp_s0->unk-8 * phi_f2;
    temp_s1->unk-4 = temp_s0->unk-4 * phi_f2;
    phi_s0 = temp_s0;
    phi_s1 = temp_s1;
    if (temp_s1 != &sp6C) {
        goto loop_1;
    }
    if (-1.0f == sp50) {
block_6:
        if (-1.0f == sp50) {
            arg1->unk4 = D_800D5C68;
            phi_f0 = atan2f(sp54, sp58);
        } else {
            arg1->unk4 = D_800D5C68;
            phi_f0 = atan2f(-sp54, sp58);
        }
        arg1->unk0 = phi_f0;
        arg1->unk8 = 0.0f;
        return;
    }
    if (1.0f == sp50) {
        goto block_6;
    }
    arg1->unk4 = asinf(-sp50);
    arg1->unk0 = atan2f(sp5C, sp68);
    arg1->unk8 = atan2f(sp4C, sp48);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A6820.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A699C(void) {
    void *temp_s0;
    void *temp_s1;
    void *temp_s2;
    void *phi_s2;
    void *phi_s0;

    phi_s2 = &D_8004A578;
loop_1:
    temp_s0 = *phi_s2;
    phi_s0 = temp_s0;
    if (temp_s0 != 0) {
loop_2:
        temp_s1 = phi_s0->unk4;
        func_8000B758_ovl1(phi_s0);
        phi_s0->unk44 = phi_s0->unk44 | 0x40;
        phi_s0 = temp_s1;
        if (temp_s1 != 0) {
            goto loop_2;
        }
    }
    temp_s2 = phi_s2 + 4;
    phi_s2 = temp_s2;
    if (temp_s2 != &D_8004A5F8) {
        goto loop_1;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A699C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800A6A18(void) {
    void *temp_s0;
    void *temp_s1;
    void *temp_s1_2;
    void *temp_s3;
    void *temp_v0;
    void *phi_s3;
    void *phi_s0;
    void *phi_s1;
    s32 phi_s0_2;
    void *phi_return;

    phi_s3 = &D_8004A578;
loop_1:
    temp_s0 = *phi_s3;
    phi_s0 = temp_s0;
    if (temp_s0 != 0) {
loop_2:
        temp_s1 = phi_s0->unk4;
        func_8000B78C_ovl1(phi_s0);
        phi_s0->unk44 = phi_s0->unk44 & -0x41;
        phi_s0 = temp_s1;
        if (temp_s1 != 0) {
            goto loop_2;
        }
    }
    temp_s3 = phi_s3 + 4;
    phi_s3 = temp_s3;
    if (temp_s3 < &D_8004A5F8) {
        goto loop_1;
    }
    phi_s1 = &D_800DD710;
    phi_s0_2 = 0;
loop_5:
    temp_v0 = &D_800DD8D0 + phi_s0_2;
    phi_return = temp_v0;
    if (-1 != *phi_s1) {
        *temp_v0 = *temp_v0 & 0xFFFF00FF;
        phi_return = func_800B1C7C_ovl1(*(&D_800DE350 + phi_s0_2));
    }
    temp_s1_2 = phi_s1 + 4;
    phi_s1 = temp_s1_2;
    phi_s0_2 = phi_s0_2 + 4;
    if (temp_s1_2 != &D_800DD8D0) {
        goto loop_5;
    }
    return phi_return;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A6A18.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A6B18(void) {

}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A6B18.s")
#endif

extern void *D_800BE8A0[];
void load_overlay(u32 arg0) {
    while (arg0 >= 0x14) {
        // ...were they going to do anything to remedy this issue?
    }
    dma_overlay_load(D_800BE8A0[arg0]);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
? func_800A6B64(void) {
    s32 sp18;
    ? phi_return;

    func_80002E48_ovl1(0xF10, &sp18, 0x10);
    if (sp18 != 0x04080040) {
        phi_return = 0;
    } else {
        phi_return = 1;
        if (sp1C != 0x02081040) {
            return 0;
        }
    }
    return phi_return;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_1/func_800A6B64.s")
#endif
