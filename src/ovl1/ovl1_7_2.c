#include <ultra64.h>
#include <macros.h>
#include "ovl1_6.h"
#include "D_8004A7C4.h"
#include "unk_structs/D_800DE350.h"
#include "ovl0/ovl0_5.h"
#include "ovl0/ovl0_6.h"

s32 func_800B3234(f32 inputX, f32 inputY, f32 inputZ);

// all of these functions are easy i think if you start incorporating MtxF's

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
void *func_800B2340(void *arg0, struct UnkStruct8004A7C4_3C *arg1, u32 arg2) {
    ? spB8;
    ? sp78;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f0_5;
    f32 temp_f0_6;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 gEntitiesNextPosZArray[track];
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f2_3;
    struct UnkStruct8004A7C4_3C *temp_s0;
    u32 phi_a2;
    struct UnkStruct8004A7C4_3C *phi_s0;

    phi_a2 = arg2;
    if (arg2 == 0xFFFF) {
        phi_a2 = D_8004A7C4->objId;
    }
    phi_s0 = arg1;
    if (arg1 == 0) {
        phi_s0 = D_8004A7C4->unk3C;
    }
    arg2 = phi_a2;
    guMtxIdentF(&spB8);
loop_5:
    if (phi_s0->unk14 != 1) {
        temp_f0 = phi_s0->unk40.x;
        if ((temp_f0 != 1.0f) || (phi_s0->unk40.y != 1.0f) || (phi_s0->unk40.z != 1.0f)) {
            HS64_MkScaleMtxF(&sp78, temp_f0, (bitwise s32) phi_s0->unk40.y, (bitwise s32) phi_s0->unk40.z);
            guMtxCatF(&spB8, &sp78, &spB8);
        }
        temp_f0_2 = phi_s0->unk30.x;
        if ((temp_f0_2 != 0.0f) || (phi_s0->unk30.y != 0.0f) || (phi_s0->unk30.z != 0.0f)) {
            HS64_MkRotationMtxF(&sp78, temp_f0_2, (bitwise f32) (bitwise s32) phi_s0->unk30.y, (bitwise f32) (bitwise s32) phi_s0->unk30.z);
            guMtxCatF(&spB8, &sp78, &spB8);
        }
        temp_f0_3 = phi_s0->unk1C.x;
        if ((temp_f0_3 != 0.0f) || (phi_s0->unk1C.y != 0.0f) || (phi_s0->unk1C.z != 0.0f)) {
            HS64_MkTranslateMtxF(&sp78, temp_f0_3, (bitwise s32) phi_s0->unk1C.y, (bitwise s32) phi_s0->unk1C.z);
            guMtxCatF(&spB8, &sp78, &spB8);
        }
    } else {
        temp_f0_4 = gEntitiesScaleXArray[arg2];
        temp_f2 = gEntitiesScaleYArray[arg2];
        temp_f12 = gEntitiesScaleZArray[arg2];
        if ((temp_f0_4 != 1.0f) || (temp_f2 != 1.0f) || (temp_f12 != 1.0f)) {
            HS64_MkScaleMtxF(temp_f12, &sp78, temp_f0_4, temp_f2, temp_f12);
            guMtxCatF(&spB8, &sp78, &spB8);
        }
        temp_f0_5 = gEntitiesAngleXArray[arg2];
        temp_f2_2 = gEntitiesAngleYArray[arg2];
        temp_f12_2 = gEntitiesAngleZArray[arg2];
        if ((temp_f0_5 != 0.0f) || (temp_f2_2 != 0.0f) || (temp_f12_2 != 0.0f)) {
            HS64_MkRotationMtxF(&sp78, temp_f0_5, temp_f2_2, temp_f12_2);
            guMtxCatF(&spB8, &sp78, &spB8);
        }
        temp_f0_6 = gEntitiesNextPosXArray[arg2];
        temp_f2_3 = gEntitiesNextPosYArray[arg2];
        temp_f12_3 = gEntitiesNextPosZArray[arg2];
        if ((temp_f0_6 != 0.0f) || (temp_f2_3 != 0.0f) || (temp_f12_3 != 0.0f)) {
            HS64_MkTranslateMtxF(temp_f12_3, &sp78, temp_f0_6, temp_f2_3, temp_f12_3);
            guMtxCatF(&spB8, &sp78, &spB8);
        }
    }
    temp_s0 = phi_s0->unk14;
    phi_s0 = temp_s0;
    if (temp_s0 != 1) {
        goto loop_5;
    }
    arg0->unk0 = spE8;
    arg0->unk4 = spEC;
    arg0->unk8 = spF0;
    return arg0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_7/func_800B2340.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
void func_800B26D8(void *arg0, struct UnkStruct8004A7C4_3C *arg1, u32 arg2) {
    f32 sp90;
    ? sp50;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f12;
    f32 temp_f2;
    f32 temp_f2_2;
    s32 temp_cond;
    struct UnkStruct8004A7C4_3C *phi_s0;
    u32 phi_s5;

    phi_s5 = arg2;
    if (arg2 == 0xFFFF) {
        phi_s5 = D_8004A7C4->objId;
    }
    phi_s0 = arg1;
    if (arg1 == 0) {
        phi_s0 = D_8004A7C4->unk3C;
    }
    guMtxIdentF(&sp90);
loop_5:
    if (phi_s0->unk14 != 1) {
        temp_f0 = phi_s0->unk30.x;
        if ((temp_f0 != 0.0f) || (phi_s0->unk30.y != 0.0f) || (phi_s0->unk30.z != 0.0f)) {
            HS64_MkRotationMtxF(&sp50, temp_f0, (bitwise f32) (bitwise s32) phi_s0->unk30.y, (bitwise f32) (bitwise s32) phi_s0->unk30.z);
            guMtxCatF(&sp90, &sp50, &sp90);
block_14:
        }
    } else {
        temp_f0_2 = gEntitiesAngleXArray[phi_s5];
        temp_f2 = gEntitiesAngleYArray[phi_s5];
        temp_f12 = gEntitiesAngleZArray[phi_s5];
        if ((temp_f0_2 != 0.0f) || (temp_f2 != 0.0f) || (temp_f12 != 0.0f)) {
            HS64_MkRotationMtxF(&sp50, temp_f0_2, temp_f2, temp_f12);
            guMtxCatF(&sp90, &sp50, &sp90);
            goto block_14;
        }
    }
    phi_s0 = phi_s0->unk14;
    if (phi_s0->unk14 != 1) {
        goto loop_5;
    }
    temp_f0_3 = asinf(-sp98);
    temp_f2_2 = D_800D67D4;
    temp_cond = temp_f0_3 == temp_f2_2;
    arg0->unk4 = temp_f0_3;
    if (temp_cond || (D_800D67D8 == arg0->unk4)) {
        if (temp_f2_2 == arg0->unk4) {
            arg0->unk0 = atan2f(spA0, spA4);
        } else {
            arg0->unk0 = atan2f(-spA0, spA4);
        }
        arg0->unk8 = 0.0f;
    } else {
        arg0->unk0 = atan2f(spA8, spB8);
        arg0->unk8 = atan2f(sp94, sp90);
    }
    func_800A4598(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_7/func_800B26D8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
void *func_800B2928(void *arg0, struct UnkStruct8004A7C4_3C *arg1, u32 arg2) {
    f32 sp90;
    ? sp50;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f12;
    f32 temp_f2;
    struct UnkStruct8004A7C4_3C *phi_s0;
    u32 phi_s5;

    phi_s5 = arg2;
    if (arg2 == 0xFFFF) {
        phi_s5 = D_8004A7C4->objId;
    }
    phi_s0 = arg1;
    if (arg1 == 0) {
        phi_s0 = D_8004A7C4->unk3C;
    }
    guMtxIdentF(&sp90);
loop_5:
    if (phi_s0->unk14 != 1) {
        temp_f0 = phi_s0->unk40.x;
        if ((temp_f0 != 1.0f) || (phi_s0->unk40.y != 1.0f) || (phi_s0->unk40.z != 1.0f)) {
            HS64_MkScaleMtxF(&sp50, temp_f0, (bitwise s32) phi_s0->unk40.y, (bitwise s32) phi_s0->unk40.z);
            guMtxCatF(&sp90, &sp50, &sp90);
block_14:
        }
    } else {
        temp_f0_2 = gEntitiesScaleXArray[phi_s5];
        temp_f2 = gEntitiesScaleYArray[phi_s5];
        temp_f12 = gEntitiesScaleZArray[phi_s5];
        if ((temp_f0_2 != 1.0f) || (temp_f2 != 1.0f) || (temp_f12 != 1.0f)) {
            HS64_MkScaleMtxF(temp_f12, &sp50, temp_f0_2, temp_f2, temp_f12);
            guMtxCatF(&sp90, &sp50, &sp90);
            goto block_14;
        }
    }
    phi_s0 = phi_s0->unk14;
    if (phi_s0->unk14 != 1) {
        goto loop_5;
    }
    arg0->unk0 = sp90;
    arg0->unk4 = spA4;
    arg0->unk8 = spB8;
    return arg0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_7/func_800B2928.s")
#endif

void func_800B2AD4(Vector *vec, struct UnkStruct8004A7C4_3C *userData, u32 track) {
    Vector tmp;
    Mat4 finalMtx; // 0xBC
    Mat4 tmpMtx; // 0x7C

    if (track == 0xFFFF) {
        track = D_8004A7C4->objId;
    }

    if (userData == 0) {
        userData = D_8004A7C4->unk3C;
    }
    guMtxIdentF(finalMtx);
    do {
        if ((u32) userData->unk14 != 1) {
            if ((userData->scaleVec.x != 1.0f) || (userData->scaleVec.y != 1.0f) || (userData->scaleVec.z != 1.0f)) {
                HS64_MkScaleMtxF(tmpMtx, 1.0f / userData->scaleVec.x, 1.0f / userData->scaleVec.y, 1.0f / userData->scaleVec.z);
                guMtxCatF(tmpMtx, finalMtx, finalMtx);
            }
            if ((userData->angleVec.x != 0.0f) || (userData->angleVec.y != 0.0f) || (userData->angleVec.z != 0.0f)) {
                func_800A465C(tmpMtx, -userData->angleVec.x, -userData->angleVec.y, -userData->angleVec.z);
                guMtxCatF(tmpMtx, finalMtx, finalMtx);
            }
            if ((userData->posVec.x != 0.0f) || (userData->posVec.y != 0.0f) || (userData->posVec.z != 0.0f)) {
                HS64_MkTranslateMtxF(tmpMtx, -userData->posVec.x, -userData->posVec.y, -userData->posVec.z);
                guMtxCatF(tmpMtx, finalMtx, finalMtx);
            }
        } else {
            if ((gEntitiesScaleXArray[track] != 1.0f) || (gEntitiesScaleYArray[track] != 1.0f) || (gEntitiesScaleZArray[track] != 1.0f)) {
                HS64_MkScaleMtxF(tmpMtx,
                    1.0f / gEntitiesScaleXArray[track],
                    1.0f / gEntitiesScaleYArray[track],
                    1.0f / gEntitiesScaleZArray[track]
                );
                guMtxCatF(tmpMtx, finalMtx, finalMtx);
            }
            if ((gEntitiesAngleXArray[track] != 0.0f) || (gEntitiesAngleYArray[track] != 0.0f) || (gEntitiesAngleZArray[track] != 0.0f)) {
                func_800A465C(tmpMtx,
                    -gEntitiesAngleXArray[track],
                    -gEntitiesAngleYArray[track],
                    -gEntitiesAngleZArray[track]
                );
                guMtxCatF(tmpMtx, finalMtx, finalMtx);
            }
            if ((gEntitiesNextPosXArray[track] != 0.0f) || (gEntitiesNextPosYArray[track] != 0.0f) || (gEntitiesNextPosZArray[track] != 0.0f)) {
                HS64_MkTranslateMtxF(tmpMtx,
                    -gEntitiesNextPosXArray[track],
                    -gEntitiesNextPosYArray[track],
                    -gEntitiesNextPosZArray[track]
                );
                guMtxCatF(tmpMtx, finalMtx, finalMtx);
            }
        }
        userData = userData->unk14;
    } while ((u32) userData != 1);

    tmp.x = vec->x;
    tmp.y = vec->y;
    tmp.z = vec->z;
    
    vec->x = ((finalMtx[0][0] * tmp.x) + (finalMtx[1][0] * tmp.y) + (finalMtx[2][0] * tmp.z))
             + finalMtx[3][0];
    vec->y = ((finalMtx[0][1] * tmp.x) + (finalMtx[1][1] * tmp.y) + (finalMtx[2][1] * tmp.z))
             + finalMtx[3][1];
    vec->z = ((finalMtx[0][2] * tmp.x) + (finalMtx[1][2] * tmp.y) + (finalMtx[2][2] * tmp.z))
             + finalMtx[3][2];
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
void func_800B2F54(s32 arg0, ? arg2) {
    func_8000FE2C_ovl1(arg2, *(&D_800D79D8 + (((arg0 - 0xA) >> 1) * 4)), arg2);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_7/func_800B2F54.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
void func_800B2F90(s32 arg0, ? arg2) {
    void *temp_s0;

    temp_s0 = *(&D_800D79D8 + (((arg0 - 0xA) >> 1) * 4));
    func_8000FE2C_ovl1(arg2, temp_s0, arg2);
loop_1:
    if (D_800D67DC != temp_s0->unk74) {
        finish_current_thread(1);
        goto loop_1;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_7/func_800B2F90.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
void func_800B3008(s32 arg0) {
loop_1:
    if (D_800D67E0 != (*(&D_800D79D8 + (((arg0 - 0xA) >> 1) * 4)))->unk74) {
        finish_current_thread(1);
        goto loop_1;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_7/func_800B3008.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
void *func_800B3070(s32 arg0, f32 arg1) {
    void *temp_v0;

    temp_v0 = *(&D_800D79D8 + (((arg0 - 0xA) >> 1) * 4));
    temp_v0->unk78 = arg1;
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_7/func_800B3070.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
void *func_800B3094(s32 arg0) {
    void *temp_v0;

    temp_v0 = *(&D_800D79D8 + (((arg0 - 0xA) >> 1) * 4));
    temp_v0->unk74 = D_800D67E4;
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_7/func_800B3094.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
s32 func_800B30BC(f32 arg0, f32 arg1, ? arg2) {
    f32 temp_f0;
    f32 temp_f0_2;
    struct Normal *temp_v1;
    f32 phi_f2;
    s32 phi_v0;
    f32 phi_f2_2;
    s32 phi_return;

    temp_v1 = &D_800E6F50[D_8004A7C4->objId];
    temp_f0 = temp_v1->x;
    if (temp_f0 < 0.0f) {
        phi_f2 = -temp_f0;
    } else {
        phi_f2 = temp_f0;
    }
    phi_v0 = 0;
    phi_return = 0;
    if (phi_f2 < arg0) {
        phi_v0 = 1;
        phi_return = 1;
    }
    if (phi_v0 != 0) {
        temp_f0_2 = temp_v1->y;
        if (temp_f0_2 < 0.0f) {
            phi_f2_2 = -temp_f0_2;
        } else {
            phi_f2_2 = temp_f0_2;
        }
        phi_return = 0;
        if (phi_f2_2 < arg1) {
            phi_return = 1;
        }
    }
    return phi_return;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_7/func_800B30BC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
? func_800B3158(void) {
    u32 temp_v0;

    temp_v0 = D_8004A7C4->objId;
    if (func_800B3234(gEntitiesNextPosXArray[temp_v0], gEntitiesNextPosYArray[temp_v0], gEntitiesNextPosZArray[temp_v0]) != 0) {
        return 0;
    }
    return 1;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_7/func_800B3158.s")
#endif

void func_800B31B4(void) {
    s32 pad;
    struct GObj *gobj = D_800DE350[D_8004A7C4->objId];

    if (func_800B3234(gEntitiesNextPosXArray[D_8004A7C4->objId], gEntitiesNextPosYArray[D_8004A7C4->objId], gEntitiesNextPosZArray[D_8004A7C4->objId]) != 0) {
        gobj->unk48 = NULL;
        func_8019B7D8_ovl1(gobj);
        func_8019D8A0_ovl1((u16) D_8004A7C4->objId);
    }
}

// Basically matches on decomp.me but not locally????
// https://decomp.me/scratch/DsIpj
#ifdef NON_MATCHING
extern const f32 D_800D67E8;
extern struct GObj *D_800D799C;
f32 func_800A4F48(void *, Vector *, f32, f32);

s32 func_800B3234(f32 inputX, f32 inputY, f32 inputZ) {
    s32 sp2C;
    Vector inVec;
    Vector delVec;

    D_800E6F50[D_8004A7C4->objId].z = 0.0f;
    if (gEntitiesNextPosYArray[D_8004A7C4->objId] < D_800D67E8) {
        D_800E6F50[D_8004A7C4->objId].z = 1.0f;
        return 1;
    }
    inVec.x = inputX;
    inVec.y = inputY;
    inVec.z = inputZ;
    sp2C = func_800A4F48(D_800D799C->unk3C, &inVec, 1.7f, 2.4f);
    D_800E6F50[D_8004A7C4->objId].x = inVec.x;
    D_800E6F50[D_8004A7C4->objId].y = inVec.y;

    delVec.x = inputX - gEntitiesNextPosXArray[0];
    delVec.y = inputY - (gEntitiesNextPosYArray[0] + 20.0f);
    delVec.z = inputZ - gEntitiesNextPosZArray[0];
    
    D_800E6F50[D_8004A7C4->objId].originOffset = sqrtf(VEC_MAG_SQUARE(delVec));
    if (sp2C == 0) {
        if (D_800E6F50[D_8004A7C4->objId].originOffset > 500.0f) {
            D_800E6F50[D_8004A7C4->objId].z = 1.0f;
            return 1;
        }
    }
    return 0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_7/func_800B3234.s")
#endif

extern f32 D_800D67EC;
void func_800B33F4(void) {
    D_800E64D0[D_8004A7C4->objId] = 0.0f;

    D_800E3050[D_8004A7C4->objId] =
    D_800E3210[D_8004A7C4->objId] =
    D_800E33D0[D_8004A7C4->objId] = D_800E64D0[D_8004A7C4->objId];

    D_800E6690[D_8004A7C4->objId] = 0.0f;

    D_800E3590[D_8004A7C4->objId] =
    D_800E3750[D_8004A7C4->objId] =
    D_800E3910[D_8004A7C4->objId] = D_800E6690[D_8004A7C4->objId];

    D_800E6850[D_8004A7C4->objId] = D_800D67EC;

    D_800E3AD0[D_8004A7C4->objId] =
    D_800E3C90[D_8004A7C4->objId] =
    D_800E3E50[D_8004A7C4->objId] = D_800E6850[D_8004A7C4->objId];
}

extern f32 D_800D67F0;
void func_800B3520(void) {
    f32 temp_f0;

    D_800E6690[D_8004A7C4->objId] = 0.0f;
    temp_f0 = D_800E6690[D_8004A7C4->objId];
    D_800E3750[D_8004A7C4->objId] = temp_f0;
    D_800E64D0[D_8004A7C4->objId] = temp_f0;
    D_800E3210[D_8004A7C4->objId] = temp_f0;
    D_800E6850[D_8004A7C4->objId] = D_800D67F0;
    D_800E3C90[D_8004A7C4->objId] = D_800E6850[D_8004A7C4->objId];
}
