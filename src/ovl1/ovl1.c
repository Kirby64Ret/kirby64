#include <ultra64.h>
#include <macros.h>

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
s32 func_8009B550_ovl1(s32 arg0, ? arg1) {
    s32 temp_s0;
    void *temp_v0;
    s32 phi_s0;
    s32 phi_s0_2;

    D_800D6AEC = 0;
    phi_s0 = 0;
    phi_s0_2 = 0;
    if (arg0 > 0) {
loop_1:
        temp_v0 = func_80005400_ovl1(arg1, 4);
        if (temp_v0 == 0) {
            phi_s0_2 = phi_s0;
        } else {
            temp_s0 = phi_s0 + 1;
            *temp_v0 = D_800D6AEC;
            D_800D6AEC = temp_v0;
            phi_s0 = temp_s0;
            phi_s0_2 = temp_s0;
            if (temp_s0 != arg0) {
                goto loop_1;
            }
block_4:
            D_800D6AE4 = 0;
            D_800D6AEA = 0;
        }
    } else {
        goto block_4;
    }
    return phi_s0_2;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009B550_ovl1.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_8009B5E8(s32 arg0, s32 arg1) {
    s32 temp_v0;
    u16 temp_t0;
    void *temp_v1;

    temp_v1 = D_800D6AEC;
    if (temp_v1 != 0) {
        D_800D6AEC = temp_v1->unk0;
        temp_v1->unk2A = 1;
        temp_v1->unk28 = arg0 & 0xFF;
        temp_v1->unkB8 = arg1 & 0xFFFF;
        temp_v1->unkB4 = 0;
        temp_v1->unkBA = 0;
        temp_v1->unk29 = D_800BE3EC;
        temp_v1->unkC = 0.0f;
        temp_v1->unk8 = 0.0f;
        temp_v1->unk4 = 0.0f;
        temp_v1->unk18 = 0.0f;
        temp_v1->unk14 = 0.0f;
        temp_v1->unk10 = 0.0f;
        temp_v1->unk24 = 1.0f;
        temp_v1->unk20 = 1.0f;
        temp_v1->unk1C = 1.0f;
        temp_t0 = D_800D6AE4 + 1;
        temp_v0 = temp_t0 & 0xFFFF;
        D_800D6AE4 = temp_t0;
        if (D_800D6AEA < temp_v0) {
            D_800D6AEA = temp_v0;
        }
    }
    return temp_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009B5E8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_8009B69C(void *arg0) {
    void *temp_v0;

    temp_v0 = arg0->unkB4;
    if (temp_v0 != 0) {
        temp_v0();
    }
    arg0->unk0 = D_800D6AEC;
    D_800D6AEC = arg0;
    D_800D6AE4 = D_800D6AE4 - 1;
    return &D_800D6AEC;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009B69C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_8009B6F0(void *arg0, s32 arg1) {
    arg0->unk60 = func_8009B5E8_ovl1(arg1 & 0xFF, arg0->unk4, arg1);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009B6F0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_8009B72C(void *arg0, s32 arg1) {
    arg0->unk4C = func_8009B5E8_ovl1(arg1 & 0xFF, arg0->unk4, arg1);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009B72C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_8009B768(s32 arg0, void *arg1, void *arg2) {
    s32 temp_a1;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 temp_v1_3;
    u16 temp_t2;
    u32 temp_a3_2;
    u32 temp_a3_3;
    u32 temp_a3_4;
    u32 temp_t1;
    u32 temp_t1_2;
    void *temp_a0;
    void *temp_a1_2;
    void *temp_a3;
    void *temp_t0;
    void *temp_t0_2;
    void *temp_t0_3;
    void *temp_t0_4;
    void *temp_t0_5;
    void *temp_t3;
    void *temp_t3_2;
    void *temp_t3_3;
    void *temp_t3_4;
    void *temp_v0;
    void *phi_a1;
    s32 phi_v1;
    void *phi_a3;
    s32 phi_v1_2;
    s32 phi_a1_2;
    void *phi_t0;
    s32 phi_t2;
    u32 phi_a3_2;
    void *phi_t0_2;
    u32 phi_t1;
    void *phi_t0_3;
    s32 phi_t2_2;
    u32 phi_a3_3;
    void *phi_t0_4;
    s32 phi_t2_3;
    u32 phi_a3_4;
    s32 phi_v1_3;

    if (arg0 < 8) {
        temp_a1 = arg0 * 4;
        temp_t0 = temp_a1 + &D_800D6A38;
        *temp_t0 = *arg1;
        temp_a0 = temp_a1 + &D_800D6A58;
        *temp_a0 = *arg2;
        *(&D_800D6A78 + temp_a1) = arg1 + 4;
        temp_v0 = temp_a1 + &D_800D6A98;
        *temp_v0 = arg2 + 4;
        if (*temp_t0 > 0) {
            phi_a1 = arg1 + 4;
            phi_v1 = 1;
loop_3:
            temp_v1 = phi_v1 + 1;
            temp_a1_2 = phi_a1 + 4;
            temp_a1_2->unk-4 = *phi_a1 + arg1;
            phi_a1 = temp_a1_2;
            phi_v1 = temp_v1;
            if (*temp_t0 >= temp_v1) {
                goto loop_3;
            }
        }
        phi_a3 = arg2 + 4;
        if (*temp_a0 > 0) {
loop_6:
            temp_v1_2 = phi_v1_2 + 1;
            temp_a3 = phi_a3 + 4;
            temp_a3->unk-4 = *phi_a3 + arg2;
            phi_a3 = temp_a3;
            phi_v1_2 = temp_v1_2;
            if (*temp_a0 >= temp_v1_2) {
                goto loop_6;
            }
        }
        if (*temp_a0 > 0) {
            phi_a1_2 = 0;
            phi_v1_3 = 0;
loop_9:
            temp_t0_2 = *(*temp_v0 + phi_a1_2);
            temp_t1 = *temp_t0_2;
            phi_t0 = temp_t0_2;
            phi_t2 = 0;
            phi_a3_2 = 0;
            phi_t0_2 = temp_t0_2;
            phi_t1 = temp_t1;
            if (temp_t1 != 0) {
loop_10:
                temp_t3 = phi_t0 + phi_t2;
                temp_a3_2 = phi_a3_2 + 1;
                temp_t3->unk18 = temp_t3->unk18 + arg2;
                temp_t0_3 = *(*temp_v0 + phi_a1_2);
                temp_t1_2 = *temp_t0_3;
                phi_t0 = temp_t0_3;
                phi_t2 = phi_t2 + 4;
                phi_a3_2 = temp_a3_2;
                phi_t0_2 = temp_t0_3;
                phi_t1 = temp_t1_2;
                if (temp_a3_2 < temp_t1_2) {
                    goto loop_10;
                }
            }
            if (2 == phi_t0_2->unk4) {
                temp_t3_2 = phi_t0_2 + (phi_t1 * 4);
                if ((phi_t0_2->unk16 & 1) != 0) {
                    temp_t3_2->unk18 = temp_t3_2->unk18 + arg2;
                } else {
                    temp_t2 = phi_t0_2->unk14;
                    if (temp_t2 != 0) {
                        if (phi_t1 < (temp_t2 + phi_t1)) {
                            phi_t0_3 = phi_t0_2;
                            phi_t2_2 = phi_t1 * 4;
                            phi_a3_3 = phi_t1;
loop_17:
                            temp_t3_3 = phi_t0_3 + phi_t2_2;
                            temp_a3_3 = phi_a3_3 + 1;
                            temp_t3_3->unk18 = temp_t3_3->unk18 + arg2;
                            temp_t0_4 = *(*temp_v0 + phi_a1_2);
                            phi_t0_3 = temp_t0_4;
                            phi_t2_2 = phi_t2_2 + 4;
                            phi_a3_3 = temp_a3_3;
                            if (temp_a3_3 < (temp_t0_4->unk14 + temp_t0_4->unk0)) {
                                goto loop_17;
                            }
                        }
                    } else {
                        if (phi_t1 < (phi_t1 * 2)) {
                            phi_t0_4 = phi_t0_2;
                            phi_t2_3 = phi_t1 * 4;
                            phi_a3_4 = phi_t1;
loop_21:
                            temp_t3_4 = phi_t0_4 + phi_t2_3;
                            temp_a3_4 = phi_a3_4 + 1;
                            temp_t3_4->unk18 = temp_t3_4->unk18 + arg2;
                            temp_t0_5 = *(*temp_v0 + phi_a1_2);
                            phi_t0_4 = temp_t0_5;
                            phi_t2_3 = phi_t2_3 + 4;
                            phi_a3_4 = temp_a3_4;
                            if (temp_a3_4 < (*temp_t0_5 * 2)) {
                                goto loop_21;
                            }
                        }
                    }
                }
            }
            temp_v1_3 = phi_v1_3 + 1;
            phi_a1_2 = phi_a1_2 + 4;
            phi_v1_3 = temp_v1_3;
            if (temp_v1_3 < *temp_a0) {
                goto loop_9;
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009B768.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
? func_8009B99C(s32 arg0) {
    s32 temp_s0;
    s32 temp_s0_2;
    u32 temp_v0;
    void *temp_v0_2;
    u32 phi_v0;
    s32 phi_s0;

    D_800D69C0 = 0;
    phi_v0 = &D_800D69C8;
loop_1:
    temp_v0 = phi_v0 + 4;
    temp_v0->unk-4 = 0;
    phi_v0 = temp_v0;
    if (temp_v0 < &D_800D6A08) {
        goto loop_1;
    }
    temp_s0 = arg0 - 1;
    phi_s0 = temp_s0;
    if (temp_s0 >= 0) {
loop_3:
        temp_v0_2 = func_80005400_ovl1(0x64, 4);
        if (temp_v0_2 == 0) {
            return 0;
        }
        temp_s0_2 = phi_s0 - 1;
        *temp_v0_2 = D_800D69C0;
        D_800D69C0 = temp_v0_2;
        phi_s0 = temp_s0_2;
        if (temp_s0_2 >= 0) {
            goto loop_3;
        }
    }
    D_800D6AE0 = 0;
    D_800D6AE6 = 0;
    if (func_8000B688_ovl1(-6) != 0) {
        return 0;
    }
    return func_8000A180(-6, &D_8009E834, 0, 0x80000000);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009B99C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_8009BA68(s32 arg0) {
    D_800D6A10 = arg0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009BA68.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_8009BA74(void *arg0, s32 arg1, s16 arg2, s32 arg3, s32 arg4, s32 arg5, f32 arg6, f32 arg7, f32 arg8, f32 arg9, f32 argA, f32 argB, f32 argC, f32 argD, f32 argE, s32 argF, void *arg10) {
    s32 temp_v0;
    u16 temp_t4;
    u16 temp_t7;
    void *temp_t5;
    void *temp_v0_2;
    void *temp_v1;

    temp_v1 = D_800D69C0;
    if (temp_v1 == 0) {
        return NULL;
    }
    temp_t7 = D_800D6AE0 + 1;
    temp_v0 = temp_t7 & 0xFFFF;
    D_800D6AE0 = temp_t7;
    if (D_800D6AE6 < temp_v0) {
        D_800D6AE6 = temp_v0;
    }
    if (arg10 != 0) {
        temp_v1->unk4 = arg10->unk4;
    } else {
        temp_t4 = D_800BE3E8 + 1;
        D_800BE3E8 = temp_t4;
        temp_v1->unk4 = temp_t4;
    }
    if (arg10 != 0) {
        temp_t5 = arg10->unk4C;
        temp_v1->unk60 = temp_t5;
        if (temp_t5 != 0) {
            temp_t5->unk2A = temp_t5->unk2A + 1;
        }
    } else {
        temp_v1->unk60 = NULL;
    }
    D_800D69C0 = temp_v1->unk0;
    if (arg0 == 0) {
        temp_v0_2 = ((arg1 >> 3) * 4) + &D_800D69C8;
        temp_v1->unk0 = *temp_v0_2;
        *temp_v0_2 = temp_v1;
    } else {
        temp_v1->unk0 = *arg0;
        *arg0 = temp_v1;
    }
    temp_v1->unk8 = arg1;
    temp_v1->unk6 = arg2;
    temp_v1->unkA = arg3 & 0xFFFF;
    temp_v1->unk24 = arg6;
    temp_v1->unk28 = arg7;
    temp_v1->unk2C = arg8;
    temp_v1->unk30 = arg9;
    temp_v1->unk34 = argA;
    temp_v1->unk38 = argB;
    temp_v1->unk44 = argC;
    temp_v1->unk3C = argD;
    temp_v1->unk40 = argE;
    temp_v1->unk1C = 0;
    temp_v1->unk1E = 0;
    temp_v1->unk22 = arg5 + 1;
    temp_v1->unk18 = arg4;
    if (argF != 0) {
        temp_v1->unk6 = arg2 | 0x10;
    }
    if (arg4 != 0) {
        temp_v1->unk10 = 1;
    } else {
        temp_v1->unk10 = 0;
    }
    temp_v1->unkC = 0xFF;
    temp_v1->unk4F = 0xFF;
    temp_v1->unk4E = 0xFF;
    temp_v1->unk4D = 0xFF;
    temp_v1->unk4C = 0xFF;
    temp_v1->unk56 = 0;
    temp_v1->unk55 = 0;
    temp_v1->unk54 = 0;
    temp_v1->unkB = 0;
    temp_v1->unk57 = 0;
    temp_v1->unk16 = 0;
    temp_v1->unk14 = 0;
    temp_v1->unk12 = 0;
    temp_v1->unk5C = arg10;
    return temp_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009BA74.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
? func_8009BC4C(s32 arg1, s32 arg2) {
    s32 temp_v0_2;
    s32 temp_v1;
    u16 temp_a3;
    void *temp_v0;

    temp_v0_2 = arg1 & 7;
    if (temp_v0_2 >= 8) {
        return 0;
    }
    temp_v1 = temp_v0_2 * 4;
    if (arg2 >= *(&D_800D6A38 + temp_v1)) {
        return 0;
    }
    temp_v0 = *(*(&D_800D6A78 + temp_v1) + (arg2 * 4));
    temp_a3 = temp_v0->unk2;
    return func_8009BA74_ovl1(temp_v0->unkA, temp_a3, temp_v0 + 0x3C, temp_v0->unk6, 0.0f, 0.0f, 0.0f, temp_v0->unk14, temp_v0->unk18, temp_v0->unk1C, temp_v0->unk2C, temp_v0->unkC, temp_v0->unk10, (*(*(&D_800D6A98 + temp_v1) + (temp_a3 * 4)))->unk16, 0);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009BC4C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
s32 func_8009BD3C(s32 arg0, ? arg1, u16 arg2, s32 arg3, s32 arg4, f32 arg5, f32 arg6, f32 arg7, f32 arg8, f32 arg9, f32 argA, f32 argB, f32 argC, f32 argD, s32 argE, s32 argF) {
    s32 sp54;
    s32 temp_v0;
    s32 phi_a0;

    temp_v0 = func_8009BA74_ovl1(0, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, argA, argB, argC, argD, argE, argF);
    phi_a0 = temp_v0;
    if (temp_v0 != 0) {
        sp54 = temp_v0;
        func_8009C4E0_ovl1(temp_v0, 0, arg0 >> 3);
        phi_a0 = sp54;
    }
    return phi_a0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009BD3C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
s32 func_8009BE04(s32 arg0, ? arg1) {
    s32 sp1C;
    s32 temp_v0;
    s32 phi_a0;

    temp_v0 = func_8009BC4C_ovl1(0, arg0, arg1);
    phi_a0 = temp_v0;
    if (temp_v0 != 0) {
        sp1C = temp_v0;
        func_8009C4E0_ovl1(temp_v0, 0, arg0 >> 3);
        phi_a0 = sp1C;
    }
    return phi_a0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009BE04.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
s32 func_8009BE54(s32 arg0, s32 arg1, f32 arg2, f32 arg3, f32 arg4, f32 arg5, f32 arg6, f32 arg7) {
    s32 sp54;
    s32 temp_v0;
    s32 temp_v0_3;
    s32 temp_v1;
    u16 temp_a3;
    void *temp_v0_2;
    s32 phi_a0;

    temp_v0 = arg0 & 7;
    if (temp_v0 >= 8) {
        return 0;
    }
    temp_v1 = temp_v0 * 4;
    if (arg1 >= *(&D_800D6A38 + temp_v1)) {
        return 0;
    }
    temp_v0_2 = *(*(&D_800D6A78 + temp_v1) + (arg1 * 4));
    temp_a3 = temp_v0_2->unk2;
    temp_v0_3 = func_8009BA74_ovl1(arg2, arg3, 0, arg0, temp_v0_2->unkA, temp_a3, temp_v0_2 + 0x3C, temp_v0_2->unk6, arg2, arg3, arg4, arg5, arg6, arg7, temp_v0_2->unk2C, temp_v0_2->unkC, temp_v0_2->unk10, (*(*(&D_800D6A98 + temp_v1) + (temp_a3 * 4)))->unk16, 0);
    phi_a0 = temp_v0_3;
    if (temp_v0_3 != 0) {
        sp54 = temp_v0_3;
        func_8009C4E0_ovl1(temp_v0_3, 0, arg0 >> 3);
        phi_a0 = sp54;
    }
    return phi_a0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009BE54.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_8009BF7C(s32 arg0, ? arg1) {
    func_8009BC4C_ovl1(0, arg0, arg1);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009BF7C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_8009BFA8(void *arg0) {
    if (arg0 != 0) {
        func_8009C4E0_ovl1(0, arg0->unk8 >> 3);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009BFA8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_8009BFD4(void *arg0) {
    void *sp18;
    void *temp_a1;
    void *temp_a1_2;
    void *temp_a2;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v1;
    void *phi_v0;
    void *phi_v1;
    void *phi_return;
    void *phi_return_2;
    void *phi_return_3;

    temp_a2 = ((arg0->unk8 >> 3) * 4) + &D_800D69C8;
    temp_v0 = *temp_a2;
    phi_v0 = temp_v0;
    phi_v1 = NULL;
    phi_return_2 = temp_v0;
    phi_return_3 = temp_v0;
    if (temp_v0 != 0) {
loop_1:
        if (phi_v0 == arg0) {
            if (phi_v1 == 0) {
                *temp_a2 = *phi_v0;
            } else {
                *phi_v1 = *phi_v0;
            }
            temp_v1 = arg0->unk5C;
            if (temp_v1 != 0) {
                if ((arg0->unk6 & 4) != 0) {
                    if (temp_v1->unk9 == 2) {
                        temp_v1->unk54 = temp_v1->unk54 - 1;
                    }
                }
            }
            temp_a1 = arg0->unk60;
            phi_return = phi_return_3;
            if (temp_a1 != 0) {
                temp_a1->unk2A = temp_a1->unk2A - 1;
                temp_a1_2 = arg0->unk60;
                phi_return = phi_return_3;
                if (temp_a1_2->unk2A == 0) {
                    sp18 = phi_v0;
                    func_8009B69C_ovl1(temp_a1_2, temp_a1_2, temp_a2);
                    phi_return = phi_v0;
                }
            }
            *phi_v0 = D_800D69C0;
            D_800D69C0 = phi_v0;
            D_800D6AE0 = D_800D6AE0 - 1;
            return phi_return;
        }
        temp_v0_2 = *phi_v0;
        phi_v0 = temp_v0_2;
        phi_v1 = phi_v0;
        phi_return_2 = temp_v0_2;
        phi_return_3 = temp_v0_2;
        if (temp_v0_2 != 0) {
            goto loop_1;
        }
    }
    return phi_return_2;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009BFD4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_8009C0E4(void) {
    void *temp_s0;
    void *temp_s1;
    void *temp_s2;
    void *phi_s2;
    void *phi_s0;

    phi_s2 = &D_800D69C8;
loop_1:
    temp_s0 = *phi_s2;
    phi_s0 = temp_s0;
    if (temp_s0 != 0) {
loop_2:
        temp_s1 = *phi_s0;
        func_8009BFD4_ovl1(phi_s0);
        phi_s0 = temp_s1;
        if (temp_s1 != 0) {
            goto loop_2;
        }
    }
    temp_s2 = phi_s2 + 4;
    phi_s2 = temp_s2;
    if (temp_s2 != &D_800D6A08) {
        goto loop_1;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009C0E4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_8009C154(void *arg0, void *arg1) {
    u8 sp7;
    u8 sp6;
    u8 sp5;
    u8 sp4;

    sp4 = arg0->unk0;
    sp5 = arg0->unk1;
    sp6 = arg0->unk2;
    sp7 = arg0->unk3;
    *arg1 = (bitwise f32) sp4;
    return arg0 + 4;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009C154.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_8009C18C(void *arg0, void *arg1) {
    u8 temp_v0;
    u8 temp_v1;
    void *temp_a0;
    u8 phi_v1;
    void *phi_a0;

    temp_v0 = *arg0;
    temp_a0 = arg0 + 1;
    phi_v1 = temp_v0;
    phi_a0 = temp_a0;
    if ((temp_v0 & 0x80) != 0) {
        temp_v1 = (*temp_a0 + ((temp_v0 & 0x7F) << 8)) & 0xFFFF;
        phi_v1 = temp_v1;
        phi_a0 = temp_a0 + 1;
    }
    *arg1 = phi_v1 + 1;
    return phi_a0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009C18C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_8009C1C8(void *arg0, f32 arg1) {
    f32 sp5C;
    f32 sp58;
    f32 sp54;
    f32 sp4C;
    f32 sp48;
    f32 sp44;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f12;
    f32 temp_f20;
    f32 temp_f20_2;
    f32 temp_f20_3;
    f32 temp_f22;
    f32 temp_f22_2;
    f32 temp_f24;
    f32 temp_f24_2;
    f32 temp_f26;
    f32 temp_f2;

    temp_f20 = arg0->unk34;
    temp_f24 = arg0->unk38;
    temp_f22 = arg0->unk30;
    temp_f0 = atan2f(temp_f20, temp_f24);
    sp58 = temp_f0;
    temp_f26 = sinf(temp_f0);
    temp_f0_2 = cosf(sp58);
    sp4C = temp_f0_2;
    temp_f0_3 = atan2f(temp_f22, (temp_f20 * temp_f26) + (temp_f24 * temp_f0_2));
    sp54 = temp_f0_3;
    sp48 = sinf(temp_f0_3);
    sp44 = cosf(sp54);
    sp5C = sqrtf(((temp_f22 * temp_f22) + (temp_f20 * temp_f20)) + (temp_f24 * temp_f24));
    temp_f20_2 = random_f32() * D_800D5660;
    temp_f24_2 = sinf(arg1) * sp5C;
    temp_f22_2 = cosf(temp_f20_2) * temp_f24_2;
    temp_f20_3 = sinf(temp_f20_2) * temp_f24_2;
    temp_f2 = cosf(arg1) * sp5C;
    temp_f12 = -temp_f22_2;
    arg0->unk30 = (temp_f22_2 * sp44) + (temp_f2 * sp48);
    arg0->unk34 = (((temp_f12 * temp_f26) * sp48) + (temp_f20_3 * sp4C)) + ((temp_f2 * temp_f26) * sp44);
    arg0->unk38 = (((temp_f12 * sp4C) * sp48) - (temp_f20_3 * temp_f26)) + ((temp_f2 * sp4C) * sp44);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009C1C8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_8009C350(void *arg0, void *arg1) {
    f32 sp24;
    f32 sp20;
    f32 sp1C;
    f32 sp18;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f16;
    f32 temp_f18;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f2_3;
    f32 temp_f6;
    f32 temp_f8;
    void *temp_a0;

    if (arg1 != 0) {
        temp_f16 = arg1->unk1C - arg0->unk24;
        temp_f18 = arg1->unk20 - arg0->unk28;
        sp1C = arg1->unk24 - arg0->unk2C;
        temp_f0 = arg0->unk30;
        temp_f2 = arg0->unk34;
        temp_f14 = arg0->unk38;
        sp20 = temp_f18;
        sp24 = temp_f16;
        temp_a0 = arg0;
        temp_f2_2 = sqrtf(((temp_f0 * temp_f0) + (temp_f2 * temp_f2)) + (temp_f14 * temp_f14), temp_f14);
        temp_f12 = ((temp_f16 * temp_f16) + (temp_f18 * temp_f18)) + (sp1C * sp1C);
        if (0.0f != temp_f12) {
            arg0 = temp_a0;
            sp18 = temp_f2_2;
            sp24 = temp_f16;
            sp20 = temp_f18;
            temp_f2_3 = temp_f2_2 / sqrtf(temp_f12, sp1C, temp_a0);
            temp_f6 = temp_f18 * temp_f2_3;
            temp_f8 = sp1C * temp_f2_3;
            arg0->unk30 = temp_f16 * temp_f2_3;
            arg0->unk34 = temp_f6;
            arg0->unk38 = temp_f8;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009C350.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_8009C44C(void *arg0, void *arg1, f32 arg2) {
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f16;
    f32 temp_f2;

    if (arg1 != 0) {
        temp_f0 = arg1->unk1C - arg0->unk24;
        temp_f2 = arg1->unk20 - arg0->unk28;
        temp_f12 = arg1->unk24 - arg0->unk2C;
        temp_f16 = ((temp_f0 * temp_f0) + (temp_f2 * temp_f2)) + (temp_f12 * temp_f12);
        if (0.0f != temp_f16) {
            temp_f14 = arg2 / temp_f16;
            arg0->unk30 = arg0->unk30 + (temp_f14 * temp_f0);
            arg0->unk34 = arg0->unk34 + (temp_f14 * temp_f2);
            arg0->unk38 = arg0->unk38 + (temp_f14 * temp_f12);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009C44C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
Failed to decompile function func_8009C4E0:

Unable to determine jump table for jr instruction.

There must be a read of a variable in the same block as
the instruction, which has a name starting with "jtbl".
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009C4E0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_8009E834(void *arg0) {
    s32 temp_s2;
    void *temp_s0;
    void *temp_v0;
    u32 phi_s3;
    s32 phi_s2;
    void *phi_s0;
    void *phi_s1;

    phi_s3 = arg0->unk44;
    phi_s2 = 0;
loop_1:
    if ((phi_s3 & 0x10000) == 0) {
        temp_s0 = *(&D_800D69C8 + (phi_s2 * 4));
        phi_s0 = temp_s0;
        phi_s1 = NULL;
        if (temp_s0 != 0) {
loop_3:
            temp_v0 = func_8009C4E0_ovl1(phi_s0, phi_s1, phi_s2);
            if (temp_v0 == *phi_s0) {
                phi_s1 = phi_s0;
            }
            phi_s0 = temp_v0;
            if (temp_v0 != 0) {
                goto loop_3;
            }
        }
    }
    temp_s2 = phi_s2 + 1;
    phi_s3 = phi_s3 >> 1;
    phi_s2 = temp_s2;
    if (temp_s2 != 0x10) {
        goto loop_1;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009E834.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
Failed to decompile function func_8009E8F4:

Unable to determine jump table for jr instruction.

There must be a read of a variable in the same block as
the instruction, which has a name starting with "jtbl".
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_8009E8F4.s")
#endif

extern Gfx* gDisplayListHeads[4];

void func_800A043C(u32 arg0, u32 arg1) {
    func_8009E8F4_ovl1(arg0, arg1, &gDisplayListHeads[0]);
}

void func_800A0460(u32 arg0) {
    func_800A043C_ovl1(arg0, 3);
}

extern u32 D_800D6A14[];

void func_800A0480(s32 arg0, u32 arg1) {
    if (arg0 > 0) {
        if (arg0 < 9) {
            D_800D6A14[arg0] = arg1;
        }
    }
}

extern s8 D_800BE3E0, D_800BE3E4;

void func_800A04A4(u32 arg0, u32 arg1) {
    D_800BE3E0 = arg0 & 0xFF;
    D_800BE3E4 = arg1 & 0xFF;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
? func_800A04B8(s32 arg0) {
    s32 temp_s0;
    s32 temp_s0_2;
    void *temp_v0;
    s32 phi_s0;

    temp_s0 = arg0 - 1;
    D_800D6A08 = 0;
    D_800D6A0C = 0;
    phi_s0 = temp_s0;
    if (temp_s0 >= 0) {
loop_1:
        temp_v0 = func_80005400_ovl1(0x78, 4);
        if (temp_v0 == 0) {
            return 0;
        }
        temp_s0_2 = phi_s0 - 1;
        *temp_v0 = D_800D6A08;
        D_800D6A08 = temp_v0;
        phi_s0 = temp_s0_2;
        if (temp_s0_2 >= 0) {
            goto loop_1;
        }
    }
    D_800D6AE2 = 0;
    D_800D6AE8 = 0;
    return func_8000A180(-7, &D_800A09AC, 0, 0x80000000);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_800A04B8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800A0558(void *arg0, void *arg1, void *arg2) {
    f32 spE0;
    f32 spDC;
    f32 spD8;
    f32 spD0;
    f32 spCC;
    f32 spC8;
    f32 spC0;
    f32 spBC;
    f32 spB8;
    ? sp78;
    f32 sp6C;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f0_5;
    f32 temp_f0_6;
    f32 temp_f20;
    f32 temp_f22;
    s32 temp_a0;
    u8 temp_v0_2;
    void *temp_s3;
    void *temp_v0;
    void *phi_s3;
    void *phi_a1;
    s32 phi_a0;
    void *phi_t0;
    void *phi_s0;
    void *phi_s1;
    void *phi_t0_2;
    void *phi_s0_2;
    void *phi_v1;
    void *phi_s1_2;

    func_80030C10_ovl1(&spB8);
    phi_s3 = arg2;
loop_1:
    temp_f0 = phi_s3->unk40;
    if (((1.0f != temp_f0) || (1.0f != phi_s3->unk44)) || (1.0f != phi_s3->unk48)) {
        func_8001B4AC_ovl1(&sp78, temp_f0, (bitwise s32) phi_s3->unk44, (bitwise s32) phi_s3->unk48);
        guMtxCatF(&spB8, &sp78, &spB8);
    } else {

    }
    temp_f0_2 = phi_s3->unk30;
    if (((0.0f != temp_f0_2) || (0.0f != phi_s3->unk34)) || (0.0f != phi_s3->unk38)) {
        guRotateRPYF(&sp78, temp_f0_2, (bitwise s32) phi_s3->unk34, (bitwise s32) phi_s3->unk38);
        guMtxCatF(&spB8, &sp78, &spB8);
    } else {

    }
    temp_f0_3 = phi_s3->unk1C;
    if (((0.0f != temp_f0_3) || (0.0f != phi_s3->unk20)) || (0.0f != phi_s3->unk24)) {
        func_8001B6E4_ovl1(&sp78, temp_f0_3, (bitwise s32) phi_s3->unk20, (bitwise s32) phi_s3->unk24);
        guMtxCatF(&spB8, &sp78, &spB8);
    } else {

    }
    temp_v0 = phi_s3->unk4C;
    if (temp_v0 != 0) {
        phi_a1 = temp_v0;
        phi_a0 = 0;
        phi_t0_2 = NULL;
        phi_s0_2 = NULL;
        phi_v1 = temp_v0 + 4;
        phi_s1_2 = NULL;
loop_15:
        temp_v0_2 = *phi_a1;
        temp_a0 = phi_a0 + 1;
        phi_t0 = phi_t0_2;
        phi_s0 = phi_s0_2;
        phi_s1 = phi_s1_2;
        if (temp_v0_2 != 0) {
            if (temp_v0_2 != 1) {
                if (temp_v0_2 != 2) {
                    if (temp_v0_2 != 3) {
                        phi_t0 = phi_t0_2;
                        phi_s0 = phi_s0_2;
                        phi_s1 = phi_s1_2;
                    } else {
                        phi_t0 = phi_v1;
                        phi_s1 = phi_s1_2;
block_23:
                        phi_s0 = phi_s0_2;
                        phi_v1 = phi_v1 + 0x10;
                    }
                } else {
                    phi_t0 = phi_t0_2;
                    phi_s0 = phi_v1;
                    phi_s1 = phi_s1_2;
                    phi_v1 = phi_v1 + 0x14;
                }
            } else {
                phi_t0 = phi_t0_2;
                phi_s1 = phi_v1;
                goto block_23;
            }
        }
        phi_a1 = phi_a1 + 1;
        phi_a0 = temp_a0;
        phi_t0_2 = phi_t0;
        phi_s0_2 = phi_s0;
        phi_s1_2 = phi_s1;
        if (temp_a0 != 3) {
            goto loop_15;
        }
        if (phi_t0 != 0) {
            temp_f0_4 = phi_t0->unk4;
            if (((1.0f != temp_f0_4) || (1.0f != phi_t0->unk8)) || (1.0f != phi_t0->unkC)) {
                func_8001B4AC_ovl1(&sp78, temp_f0_4, (bitwise s32) phi_t0->unk8, (bitwise s32) phi_t0->unkC);
                guMtxCatF(&spB8, &sp78, &spB8);
            } else {

            }
        }
        if (phi_s0 != 0) {
            temp_f0_5 = phi_s0->unk8;
            if (((0.0f != temp_f0_5) || (0.0f != phi_s0->unkC)) || (0.0f != phi_s0->unk10)) {
                guRotateRPYF(&sp78, temp_f0_5, (bitwise s32) phi_s0->unkC, (bitwise s32) phi_s0->unk10);
                guMtxCatF(&spB8, &sp78, &spB8);
            } else {

            }
        }
        if (phi_s1 != 0) {
            temp_f0_6 = phi_s1->unk4;
            if (((0.0f != temp_f0_6) || (0.0f != phi_s1->unk8)) || (0.0f != phi_s1->unkC)) {
                func_8001B6E4_ovl1(&sp78, temp_f0_6, (bitwise s32) phi_s1->unk8, (bitwise s32) phi_s1->unkC);
                guMtxCatF(&spB8, &sp78, &spB8);
            } else {

            }
        }
    }
    temp_s3 = phi_s3->unk14;
    phi_s3 = temp_s3;
    if (temp_s3 != 1) {
        goto loop_1;
    }
    arg0->unk0 = spE8;
    arg0->unk4 = spEC;
    arg0->unk8 = spF0;
    temp_f22 = arg1->unk4;
    temp_f20 = arg1->unk0;
    sp6C = arg1->unk8;
    guNormalize(&spB8, &spC8, &spD8);
    guNormalize(&spBC, &spCC, &spDC);
    guNormalize(&spC0, &spD0, &spE0);
    arg1->unk0 = (spD8 * sp6C) + ((spB8 * temp_f20) + (spC8 * temp_f22));
    arg1->unk4 = (spDC * sp6C) + ((spBC * temp_f20) + (spCC * temp_f22));
    arg1->unk8 = (spE0 * sp6C) + ((spC0 * temp_f20) + (spD0 * temp_f22));
    return arg1;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_800A0558.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
Failed to decompile function func_800A09AC:

Unable to determine jump table for jr instruction.

There must be a read of a variable in the same block as
the instruction, which has a name starting with "jtbl".
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_800A09AC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800A194C(void) {
    s32 temp_v0;
    u16 temp_t4;
    u16 temp_t7;
    void *temp_v1;

    temp_v1 = D_800D6A08;
    if (temp_v1 == 0) {
        return NULL;
    }
    temp_t7 = D_800D6AE2 + 1;
    temp_v0 = temp_t7 & 0xFFFF;
    D_800D6AE2 = temp_t7;
    if (D_800D6AE8 < temp_v0) {
        D_800D6AE8 = temp_v0;
    }
    D_800D6A08 = temp_v1->unk0;
    temp_v1->unk0 = D_800D6A0C;
    D_800D6A0C = temp_v1;
    if (D_800D6AF0 == 0) {
        D_800D6AF0 = temp_v1;
    }
    temp_t4 = D_800BE3E8 + 1;
    D_800BE3E8 = temp_t4;
    temp_v1->unk4 = temp_t4;
    temp_v1->unk4C = 0;
    return temp_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_800A194C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
Failed to decompile function func_800A19EC:

Unable to determine jump table for jr instruction.

There must be a read of a variable in the same block as
the instruction, which has a name starting with "jtbl".
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_800A19EC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800A1F30(void *arg0) {
    void *sp18;
    void *temp_a1;
    void *temp_a1_2;
    void *temp_v0;
    void *temp_v0_2;
    void *phi_v0;
    void *phi_v1;
    void *phi_return;
    void *phi_return_2;
    void *phi_return_3;

    temp_v0 = D_800D6A0C;
    phi_v0 = temp_v0;
    phi_v1 = NULL;
    phi_return = temp_v0;
    phi_return_3 = temp_v0;
    if (temp_v0 != 0) {
loop_1:
        if (phi_v0 == arg0) {
            if (arg0->unk9 != 2) {
block_5:
                if (phi_v1 == 0) {
                    D_800D6A0C = *phi_v0;
                } else {
                    *phi_v1 = *phi_v0;
                }
                temp_a1 = arg0->unk4C;
                phi_return_2 = phi_return;
                if (temp_a1 != 0) {
                    temp_a1->unk2A = temp_a1->unk2A - 1;
                    temp_a1_2 = arg0->unk4C;
                    phi_return_2 = phi_return;
                    if (temp_a1_2->unk2A == 0) {
                        sp18 = phi_v0;
                        func_8009B69C_ovl1(temp_a1_2, temp_a1_2);
                        phi_return_2 = phi_v0;
                    }
                }
                *phi_v0 = D_800D6A08;
                D_800D6A08 = phi_v0;
                D_800D6AE2 = D_800D6AE2 - 1;
                return phi_return_2;
            }
            if (arg0->unk54 == 0) {
                goto block_5;
            }
            arg0->unkE = 1;
            arg0->unk40 = 0.0f;
            return phi_return;
        }
        temp_v0_2 = *phi_v0;
        phi_v0 = temp_v0_2;
        phi_v1 = phi_v0;
        phi_return = temp_v0_2;
        phi_return_3 = temp_v0_2;
        if (temp_v0_2 != 0) {
            goto loop_1;
        }
    }
    return phi_return_3;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_800A1F30.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A2024(void) {
    void *temp_s0;
    void *temp_s1;
    void *phi_s0;

    temp_s0 = D_800D6A0C;
    phi_s0 = temp_s0;
    if (temp_s0 != 0) {
loop_1:
        temp_s1 = *phi_s0;
        func_800A1F30_ovl1(phi_s0);
        phi_s0 = temp_s1;
        if (temp_s1 != 0) {
            goto loop_1;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_800A2024.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A206C(s32 arg0, ?32 arg1) {
    D_800D6ADC = arg0;
    D_800D6AD8 = arg1;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_800A206C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A2080(s32 arg0, s32 arg1) {
    s32 temp_fp;
    void *temp_a0;
    void *temp_a0_2;
    void *temp_a0_3;
    void *temp_a0_4;
    void *temp_s0;
    void *temp_s0_2;
    void *temp_s6;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *phi_s0;
    void *phi_s1;
    void *phi_s0_2;
    void *phi_s1_2;

    temp_s6 = (arg1 * 4) + &D_800D69C8;
    temp_s0 = *temp_s6;
    temp_fp = arg0 & 0xFFFF;
    if (temp_s0 != 0) {
        phi_s0 = temp_s0;
        phi_s1 = NULL;
loop_2:
        temp_v0 = phi_s0->unk0;
        if (temp_fp == phi_s0->unk4) {
            if (phi_s1 == 0) {
                *temp_s6 = temp_v0;
            } else {
                *phi_s1 = temp_v0;
            }
            temp_v0_2 = phi_s0->unk5C;
            if (temp_v0_2 != 0) {
                if ((phi_s0->unk6 & 4) != 0) {
                    if (2 == temp_v0_2->unk9) {
                        temp_v0_2->unk54 = temp_v0_2->unk54 - 1;
                    }
                }
            }
            temp_a0 = phi_s0->unk60;
            if (temp_a0 != 0) {
                temp_a0->unk2A = temp_a0->unk2A - 1;
                temp_a0_2 = phi_s0->unk60;
                if (temp_a0_2->unk2A == 0) {
                    func_8009B69C_ovl1(temp_a0_2);
                }
            }
            phi_s0->unk0 = D_800D69C0;
            D_800D69C0 = phi_s0;
            D_800D6AE0 = D_800D6AE0 - 1;
        } else {
            phi_s1 = phi_s0;
        }
        phi_s0 = temp_v0;
        if (temp_v0 != 0) {
            goto loop_2;
        }
    }
    temp_s0_2 = D_800D6A0C;
    if (temp_s0_2 != 0) {
        phi_s0_2 = temp_s0_2;
        phi_s1_2 = NULL;
loop_18:
        temp_v0_3 = phi_s0_2->unk0;
        if (temp_fp == phi_s0_2->unk4) {
            if (2 == phi_s0_2->unk9) {
                if (phi_s0_2->unk54 != 0) {
                    phi_s0_2->unk40 = 0.0f;
                    phi_s0_2->unkE = 1;
block_29:
                    phi_s1_2 = phi_s0_2;
                } else {
block_22:
                    if (phi_s1_2 == 0) {
                        D_800D6A0C = temp_v0_3;
                    } else {
                        *phi_s1_2 = temp_v0_3;
                    }
                    temp_a0_3 = phi_s0_2->unk4C;
                    if (temp_a0_3 != 0) {
                        temp_a0_3->unk2A = temp_a0_3->unk2A - 1;
                        temp_a0_4 = phi_s0_2->unk4C;
                        if (temp_a0_4->unk2A == 0) {
                            func_8009B69C_ovl1(temp_a0_4);
                        }
                    }
                    phi_s0_2->unk0 = D_800D6A08;
                    D_800D6A08 = phi_s0_2;
                    D_800D6AE2 = D_800D6AE2 - 1;
                }
            } else {
                goto block_22;
            }
        } else {
            goto block_29;
        }
        phi_s0_2 = temp_v0_3;
        if (temp_v0_3 != 0) {
            goto loop_18;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_800A2080.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A22A8(void *arg0) {
    func_800A2080_ovl1(arg0->unk4, arg0->unk8 >> 3, arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_800A22A8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A22D4(void *arg0) {
    func_800A2080_ovl1(arg0->unk4, arg0->unkA >> 3, arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_800A22D4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800A2300(void *arg0) {
    s32 temp_s1;
    s32 temp_v0;
    void *temp_a0;
    void *temp_s0;
    s32 phi_s1;
    void *phi_a0;

    if (arg0->unkF == 1) {
        temp_s1 = arg0->unk3C;
        phi_s1 = temp_s1;
        if (temp_s1 != 0) {
loop_2:
            temp_a0 = D_800D6A0C;
            phi_a0 = temp_a0;
            if (temp_a0 != 0) {
loop_3:
                temp_s0 = phi_a0->unk0;
                if (phi_s1 == phi_a0->unk48) {
                    func_800A1F30_ovl1(phi_a0);
                }
                phi_a0 = temp_s0;
                if (temp_s0 != 0) {
                    goto loop_3;
                }
            }
            temp_v0 = func_8000BE90_ovl1(phi_s1);
            phi_s1 = temp_v0;
            if (temp_v0 != 0) {
                goto loop_2;
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_800A2300.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800A238C(f32 arg0, f32 arg1, f32 arg2) {
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v1;
    void *phi_v1;
    void *phi_v0;
    void *phi_v0_2;
    void *phi_return;

    phi_v1 = &D_800D69C8;
loop_1:
    temp_v0 = *phi_v1;
    temp_v1 = phi_v1 + 4;
    phi_v0 = temp_v0;
    if (temp_v0 != 0) {
loop_2:
        phi_v0->unk24 = phi_v0->unk24 + arg0;
        phi_v0->unk28 = phi_v0->unk28 + arg1;
        phi_v0->unk2C = phi_v0->unk2C + arg2;
        temp_v0_2 = phi_v0->unk0;
        phi_v0 = temp_v0_2;
        if (temp_v0_2 != 0) {
            goto loop_2;
        }
    }
    phi_v1 = temp_v1;
    if (temp_v1 < &D_800D6A08) {
        goto loop_1;
    }
    temp_v0_3 = D_800D6A0C;
    phi_v0_2 = temp_v0_3;
    phi_return = temp_v0_3;
    if (temp_v0_3 != 0) {
loop_5:
        phi_v0_2->unk14 = phi_v0_2->unk14 + arg0;
        phi_v0_2->unk18 = phi_v0_2->unk18 + arg1;
        phi_v0_2->unk1C = phi_v0_2->unk1C + arg2;
        temp_v0_4 = phi_v0_2->unk0;
        phi_v0_2 = temp_v0_4;
        phi_return = temp_v0_4;
        if (temp_v0_4 != 0) {
            goto loop_5;
        }
    }
    return phi_return;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_800A238C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800A2440(s32 arg0, s32 arg1) {
    s32 temp_a0;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *phi_v0;
    void *phi_v0_2;
    void *phi_return;

    temp_v0 = *(&D_800D69C8 + (arg1 * 4));
    temp_a0 = arg0 & 0xFFFF;
    phi_v0 = temp_v0;
    if (temp_v0 != 0) {
loop_1:
        if (temp_a0 == phi_v0->unk4) {
            phi_v0->unk6 = phi_v0->unk6 | 0x800;
        }
        temp_v0_2 = phi_v0->unk0;
        phi_v0 = temp_v0_2;
        if (temp_v0_2 != 0) {
            goto loop_1;
        }
    }
    temp_v0_3 = D_800D6A0C;
    phi_v0_2 = temp_v0_3;
    phi_return = temp_v0_3;
    if (temp_v0_3 != 0) {
loop_5:
        if (temp_a0 == phi_v0_2->unk4) {
            phi_v0_2->unk6 = phi_v0_2->unk6 | 0x800;
        }
        temp_v0_4 = phi_v0_2->unk0;
        phi_v0_2 = temp_v0_4;
        phi_return = temp_v0_4;
        if (temp_v0_4 != 0) {
            goto loop_5;
        }
    }
    return phi_return;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_800A2440.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800A24C4(s32 arg0, s32 arg1) {
    s32 temp_a0;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *phi_v0;
    void *phi_v0_2;
    void *phi_return;

    temp_v0 = *(&D_800D69C8 + (arg1 * 4));
    temp_a0 = arg0 & 0xFFFF;
    if (temp_v0 != 0) {
        phi_v0 = temp_v0;
loop_2:
        if (temp_a0 == phi_v0->unk4) {
            phi_v0->unk6 = phi_v0->unk6 & -0x801;
        }
        temp_v0_2 = phi_v0->unk0;
        phi_v0 = temp_v0_2;
        if (temp_v0_2 != 0) {
            goto loop_2;
        }
    }
    temp_v0_3 = D_800D6A0C;
    phi_v0_2 = temp_v0_3;
    phi_return = temp_v0_3;
    if (temp_v0_3 != 0) {
loop_6:
        if (temp_a0 == phi_v0_2->unk4) {
            phi_v0_2->unk6 = phi_v0_2->unk6 & -0x801;
        }
        temp_v0_4 = phi_v0_2->unk0;
        phi_v0_2 = temp_v0_4;
        phi_return = temp_v0_4;
        if (temp_v0_4 != 0) {
            goto loop_6;
        }
    }
    return phi_return;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_800A24C4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
Failed to decompile function func_800A2550:

Unable to determine jump table for jr instruction.

There must be a read of a variable in the same block as
the instruction, which has a name starting with "jtbl".
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1/func_800A2550.s")
#endif
